<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>Язык программирования Оберон-2 (перевод с английского)</TITLE>
   <META NAME="Author" CONTENT="С.Свердлов">
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (Win95; I) [Netscape]">
   <META NAME="KeyWords" CONTENT="Oberon, Оберон, язык программирования, programming language">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<P><B><I>This document is in Windows 1251 cyrillic coding</I></B></P>

<CENTER><P><A HREF="ftp://ftp.inf.ethz.ch/pub/software/Oberon/Docu/Oberon2.Report.Text"><FONT SIZE=+1>The
Programming Language Oberon-2<BR>
</FONT>H.Moessenboeck, N.Wirth<BR>
Institut fur Computersysteme, ETH Zurich <BR>
July 1996</A></P></CENTER>

<H1 ALIGN=CENTER>Язык программирования Оберон-2 </H1>

<H2 ALIGN=CENTER>Х.Мёссенбёк, Н.Вирт </H2>

<CENTER><P><I>Институт компьютерных систем, ETH, Цюрих </I></P></CENTER>

<CENTER><P><I>Июль 1996 </I></P></CENTER>

<CENTER><P><I>Перевод с английского С.Свердлова </I></P></CENTER>

<H2>От переводчика </H2>

<P>Язык программирования Оберон создан автором Паскаля и Модулы-2 <A HREF="http://www.cs.inf.ethz.ch/~wirth/">Никлаусом
Виртом</A> в 1987 году в ходе разработки одноименной операционной системы
для однопользовательской рабочей станции Ceres. Язык и операционная система
названы именем одного из спутников планеты Уран - Оберона, открытого английским
астрономом Уильямом Гершелем ровно за двести лет до описываемых событий.<BR>
     &quot;Сделай так просто, как возможно, но не проще того&quot; - это
высказывание А.Эйнштейна Вирт выбрал эпиграфом к описанию языка. Удивительно
простой и даже аскетичный Оберон является, вероятно, минимальным универсальным
языком высокого уровня. Он проще Паскаля и Модулы-2 и в то же время обогащает
их рядом новых возможностей. Важно то, что автором языка руководили не
сиюминутные коммерческие и конъюнктурные соображения, а глубокий анализ
реальных программистских потребностей и стремление удовлетворить их простым,
понятным, эффективным и безопасным образом, не вводя по возможности новых
понятий. <BR>
     Являясь объектно-ориентированным языком, Оберон даже не содержит слова
object. Оберон представляется идеальным языком для изучения программирования.
Сочетание простоты, строгости и неизбыточности предоставляет начинающему
программисту великолепную возможность, не заблудившись в дебрях, выработать
хороший стиль, освоив при этом и структурное и объектно-ориентированное
и модульно-компонентное программирование. <BR>
     В 1992 году сотрудничество Н.Вирта с <A HREF="http://oberon.ssw.uni-linz.ac.at/Staff/HM.html">Ханспетером
Мёссенбёком</A> привело к добавлению в язык ряда новых средств. Новая версия
получила название Оберон-2. Описание именно этого языка по состоянию на
1 октября 1996 года (последние изменения внесены авторами в июле 1996 года)
и дается в настоящем переводе. Оберон-2 представляет собой почти правильное
расширение Оберона и является фактическим стандартом языка, который поддерживается
большинством современных Оберон-систем. В Оберон-2 добавлены: </P>

<UL>
<LI>связанные с типом процедуры; </LI>

<LI>экспорт только для чтения; </LI>

<LI>открытые массивы в качестве базового типа для указателей; </LI>

<LI>оператор with с вариантами; </LI>

<LI>оператор for. </LI>
</UL>

<P>Отдельного внимания заслуживает само описание, с которым вам предстоит
познакомиться. Вирт и его соавтор достигли совершенства не только в искусстве
разработки, но, несомненно, и в деле описания языков программирования.
Поражают изумительная точность и краткость этого документа. Почти каждая
его фраза превращается при написании компилятора в конкретные строки программного
кода. <BR>
     Возникшие при переводе описания Оберона-2 на русский язык терминологические
вопросы решались исходя из следующих соображений: предпочтительным является
буквальный перевод; недопустимо добавление терминов, отсутствующих в оригинале;
должны быть учтены отечественные традиции в терминологии алголоподобных
языков; предпочтительно использование терминов, привычных широкому кругу
программистов, вместо узкоспециальных. Ниже приведен список терминов, перевод
которых не представляется очевидным.</P>

<TABLE CELLPADDING=0 >
<TR>
<TD>(direct) base type</TD>

<TD>(непосредственный) базовый тип</TD>
</TR>

<TR>
<TD>array compatible</TD>

<TD>совместимый массив</TD>
</TR>

<TR>
<TD>array type</TD>

<TD>тип массив</TD>
</TR>

<TR>
<TD>assignment compatible    </TD>

<TD>совместимый по присваиванию</TD>
</TR>

<TR>
<TD>basic type</TD>

<TD>основной тип</TD>
</TR>

<TR>
<TD>browser</TD>

<TD>смотритель</TD>
</TR>

<TR>
<TD>case statement</TD>

<TD>оператор case</TD>
</TR>

<TR>
<TD>character</TD>

<TD>символ, знак</TD>
</TR>

<TR>
<TD>declaration</TD>

<TD>объявление</TD>
</TR>

<TR>
<TD>designator</TD>

<TD>обозначение</TD>
</TR>

<TR>
<TD>direct extension</TD>

<TD>непосредственное расширение</TD>
</TR>

<TR>
<TD>equal types</TD>

<TD>равные типы</TD>
</TR>

<TR>
<TD>exit statement</TD>

<TD>оператор выхода</TD>
</TR>

<TR>
<TD>expression compatible</TD>

<TD>совместимое выражение</TD>
</TR>

<TR>
<TD>for statement</TD>

<TD>оператор for</TD>
</TR>

<TR>
<TD>function procedure</TD>

<TD>процедура-функция</TD>
</TR>

<TR>
<TD>if statement</TD>

<TD>оператор if</TD>
</TR>

<TR>
<TD>loop statement</TD>

<TD>оператор loop</TD>
</TR>

<TR>
<TD>matching</TD>

<TD>совпадение</TD>
</TR>

<TR>
<TD>operator</TD>

<TD>операция</TD>
</TR>

<TR>
<TD>pointer type</TD>

<TD>тип указатель</TD>
</TR>

<TR>
<TD>predeclared</TD>

<TD>стандартный</TD>
</TR>

<TR>
<TD>private field</TD>

<TD>скрытое поле</TD>
</TR>

<TR>
<TD>proper procedure</TD>

<TD>собственно процедура</TD>
</TR>

<TR>
<TD>public field</TD>

<TD>доступное поле</TD>
</TR>

<TR>
<TD>qualified</TD>

<TD>уточненный</TD>
</TR>

<TR>
<TD>real</TD>

<TD>вещественный</TD>
</TR>

<TR>
<TD>record type</TD>

<TD>тип запись</TD>
</TR>

<TR>
<TD>repeat statement</TD>

<TD>оператор repeat</TD>
</TR>

<TR>
<TD>return statement</TD>

<TD>оператор возврата</TD>
</TR>

<TR>
<TD>same type</TD>

<TD>одинаковый тип</TD>
</TR>

<TR>
<TD>scale factor</TD>

<TD>порядок</TD>
</TR>

<TR>
<TD>scope</TD>

<TD>область действия</TD>
</TR>

<TR>
<TD>statement</TD>

<TD>оператор</TD>
</TR>

<TR>
<TD>string</TD>

<TD>строка</TD>
</TR>

<TR>
<TD>symbol</TD>

<TD>слово</TD>
</TR>

<TR>
<TD>type extension</TD>

<TD>расширение типа</TD>
</TR>

<TR>
<TD>type guard</TD>

<TD>охрана типа</TD>
</TR>

<TR>
<TD>type inclusion</TD>

<TD>поглощение типа</TD>
</TR>

<TR>
<TD>type tag</TD>

<TD>тег</TD>
</TR>

<TR>
<TD>type test</TD>

<TD>проверка типа</TD>
</TR>

<TR>
<TD>type-bound procedures</TD>

<TD>связанные с типом процедуры</TD>
</TR>

<TR>
<TD>while statement</TD>

<TD>оператор while</TD>
</TR>

<TR>
<TD>with statement</TD>

<TD>оператор with</TD>
</TR>
</TABLE>

<P><A href="http://www.uni-vologda.ac.ru/~c3c/index.html">С. Свердлов</A> <BR>
<A href="mailto:с3с@uni-vologda.ac.ru">с3с@uni-vologda.ac.ru<BR>
</A>2 октября 1996 г. - 12 июня 1998 г.<BR>
Вологда </P>

<H2>Введение </H2>

<P>Оберон-2 - язык программирования общего назначения, продолжающий традицию
языков Паскаль и Modula-2. Его основные черты - блочная структура, модульность,
раздельная компиляция, статическая типизация со строгим контролем соответствия
типов (в том числе межмодульным), а также расширение типов и связанные
с типами процедуры. <BR>
     Расширение типов делает Оберон-2 объектно-ориентированным языком.
Объект - это переменная абстрактного типа, содержащая данные (состояние
объекта) и процедуры, которые оперируют этими данными. Абстрактные типы
данных определены как расширяемые записи. Оберон-2 перекрывает большинство
терминов объектно-ориентированных языков привычным словарем языков императивных,
обходясь минимумом понятий в рамках тех же концепций. <BR>
     Этот документ не является учебником программирования. Он преднамеренно
краток. Его назначение - служить справочником для программистов, разработчиков
компиляторов и авторов руководств. Если о чем-то не сказано, то обычно
сознательно: или потому, что это следует из других правил языка, или потому,
что потребовалось бы определять то, что фиксировать для общего случая представляется
неразумным. <BR>
     В <A href="#Приложение a: Определение терминов">приложении A</A> определены
некоторые термины, которые используются при описании правил соответствия
типов Оберона-2. В тексте эти термины выделены курсивом, чтобы подчеркнуть
их специальное значение (например, <I><A href="#Одинаковые">одинаковый</A></I>
тип). </P>

<H2>2. Синтаксис </H2>

<P>Для описания синтаксиса Оберона-2 используются Расширенные Бэкуса-Наура
Формы (РБНФ). Варианты разделяются знаком |. Квадратные скобки [ и ] означают
необязательность записанного внутри них выражения, а фигурные скобки {
и } означают его повторение (возможно 0 раз). Нетерминальные символы начинаются
с заглавной буквы (например, Оператор). Терминальные символы или начинаются
малой буквой (например, идент), или записываются целиком заглавными буквами
(например, BEGIN), или заключаются в кавычки (например, &quot;:=&quot;).
</P>

<H2><A NAME="3. Словарь и представление"></A>3. Словарь и представление
</H2>

<P>Для представления терминальных символов предусматривается использование
набора знаков ASCII. Слова языка - это идентификаторы, числа, строки, операции
и разделители. Должны соблюдаться следующие лексические правила. Пробелы
и концы строк не должны встречаться внутри слов (исключая комментарии и
пробелы в символьных строках). Пробелы и концы строк игнорируются, если
они не существенны для отделения двух последовательных слов. Заглавные
и строчные буквы считаются различными. </P>

<P>1. <I>Идентификаторы</I> - последовательности букв и цифр. Первый символ
должен быть буквой. </P>

<UL>
<P>идент = буква {буква | цифра}. </P>
</UL>

<P>Примеры: x  Scan  Oberon2  GetSymbol  firstLetter </P>

<P>2. <I>Числа</I> - целые или вещественные (без знака) константы. Типом
целочисленной константы считается минимальный тип, которому принадлежит
ее значение (<A href="#6.1 Основные типы">см. 6.1</A>). Если константа
заканчивается буквой H, она является шестнадцатеричной, иначе - десятичной.
</P>

<P>Вещественное число всегда содержит десятичную точку. Оно может также
содержать десятичный порядок. Буква E (или D) означает &quot;умножить на
десять в степени&quot;. Вещественное число относится к типу REAL кроме
случая, когда у него есть порядок, содержащий букву D. В этом случае оно
относится к типу LONGREAL. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>число</TD>

<TD> = </TD>

<TD>целое | вещественное.</TD>
</TR>

<TR>
<TD>целое</TD>

<TD> = </TD>

<TD>цифра {цифра} | цифра {шестнЦифра} &quot;H&quot;.</TD>
</TR>

<TR>
<TD>вещественное  </TD>

<TD> = </TD>

<TD>цифра {цифра} &quot;.&quot; {цифра} [Порядок].</TD>
</TR>

<TR>
<TD>Порядок</TD>

<TD> = </TD>

<TD>(&quot;E&quot; | &quot;D&quot;) [&quot;+&quot; | &quot;-&quot;] цифра
{цифра}.</TD>
</TR>

<TR>
<TD>шестнЦифра</TD>

<TD> = </TD>

<TD>цифра | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot;
| &quot;E&quot; | &quot;F&quot;.</TD>
</TR>

<TR>
<TD>цифра</TD>

<TD> = </TD>

<TD>&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot;
| &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;.</TD>
</TR>
</TABLE>
</UL>

<P>Примеры:  </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>1991</TD>

<TD>INTEGER</TD>

<TD>1991</TD>
</TR>

<TR>
<TD>0DH</TD>

<TD>SHORTINT</TD>

<TD>13</TD>
</TR>

<TR>
<TD>12.3</TD>

<TD>REAL</TD>

<TD>12.3</TD>
</TR>

<TR>
<TD>4.567E8</TD>

<TD>REAL</TD>

<TD>456700000</TD>
</TR>

<TR>
<TD>0.57712566D-6   </TD>

<TD>LONGREAL   </TD>

<TD>0.00000057712566</TD>
</TR>
</TABLE>
</UL>

<P>3. <I>Символьные </I>константы обозначаются порядковым номером символа
в шестнадцатеричной записи, оканчивающейся буквой X. </P>

<UL>
<P>символ = цифра {шестнЦифра} &quot;X&quot;. </P>
</UL>

<P>4. <I>Строки </I>- последовательности символов, заключенные в одиночные
(') или двойные (&quot;) кавычки. Открывающая кавычка должна быть такой
же, что и закрывающая и не должна встречаться внутри строки. Число символов
в строке называется ее <I>длиной</I>. Строка длины 1 может использоваться
везде, где допустима символьная константа и наоборот. </P>

<UL>
<P>строка = ' &quot; ' {символ} ' &quot; ' | &quot; ' &quot; {символ} &quot;
' &quot;. </P>
</UL>

<P>Примеры: &quot;Oberon-2&quot;    &quot;Don't worry!&quot;    &quot;x&quot;
</P>

<P>5. <I>Операции и разделители</I> - это специальные символы, пары символов
или зарезервированные слова, перечисленные ниже. Зарезервированные слова
состоят исключительно из заглавных букв и не могут использоваться как идентификаторы.
</P>

<TABLE>
<TR>
<TD>+       </TD>

<TD>:=       </TD>

<TD>IMPORT     </TD>

<TD>ARRAY</TD>

<TD>RETURN</TD>
</TR>

<TR>
<TD>-</TD>

<TD>^</TD>

<TD>BEGIN</TD>

<TD>IN</TD>

<TD>THEN</TD>
</TR>

<TR>
<TD>*</TD>

<TD>=</TD>

<TD>BY</TD>

<TD>IS</TD>

<TD>TO</TD>
</TR>

<TR>
<TD>/</TD>

<TD>#</TD>

<TD>CASE</TD>

<TD>LOOP</TD>

<TD>TYPE</TD>
</TR>

<TR>
<TD>~</TD>

<TD>&lt;</TD>

<TD>CONST</TD>

<TD>MOD</TD>

<TD>UNTIL</TD>
</TR>

<TR>
<TD>&amp;</TD>

<TD>&gt;</TD>

<TD>DIV</TD>

<TD>MODULE</TD>

<TD>VAR</TD>
</TR>

<TR>
<TD>.</TD>

<TD>&lt;=</TD>

<TD>DO</TD>

<TD>NIL</TD>

<TD>WHILE</TD>
</TR>

<TR>
<TD>,</TD>

<TD>&gt;=</TD>

<TD>ELSE</TD>

<TD>OF</TD>

<TD>WITH</TD>
</TR>

<TR>
<TD>;</TD>

<TD>..</TD>

<TD>ELSIF</TD>

<TD>OR</TD>

<TD></TD>
</TR>

<TR>
<TD>|</TD>

<TD>:</TD>

<TD>END</TD>

<TD>POINTER</TD>

<TD></TD>
</TR>

<TR>
<TD>(</TD>

<TD>)</TD>

<TD>EXIT</TD>

<TD>PROCEDURE    </TD>

<TD></TD>
</TR>

<TR>
<TD>[</TD>

<TD>]</TD>

<TD>FOR</TD>

<TD>RECORD</TD>

<TD></TD>
</TR>

<TR>
<TD>{</TD>

<TD>}</TD>

<TD>IF</TD>

<TD>REPEAT</TD>

<TD></TD>
</TR>
</TABLE>

<P>6.<I> Комментарии </I>могут быть вставлены между любыми двумя словами
программы. Это произвольные последовательности символов, начинающиеся скобкой
(* и оканчивающиеся *). Комментарии могут быть вложенными. Они не влияют
на смысл программы. </P>

<H2><A NAME="4. Объявления и области действия"></A>4. Объявления и области
действия </H2>

<P>Каждый идентификатор, встречающийся в программе, должен быть объявлен,
если это не стандартный идентификатор. Объявления задают некоторые постоянные
свойства объекта, например, является ли он константой, типом, переменной
или процедурой. После объявления идентификатор используется для ссылки
на соответствующий объект. </P>

<P><I>Область действия</I> объекта <I>x</I> распространяется текстуально
от точки его объявления до конца блока (модуля, процедуры или записи),
в котором находится объявление. Для этого блока объект является <I>локальным</I>.
Это разделяет области действия одинаково именованных объектов, которые
объявлены во вложенных блоках. Правила для областей действия таковы: </P>

<OL>
<LI>Идентификатор не может обозначать больше чем один объект внутри данной
области действия (то есть один и тот же идентификатор не может быть объявлен
в блоке дважды); </LI>

<LI>Ссылаться на объект можно только изнутри его области действия; </LI>

<LI>Тип<I> T</I> вида POINTER TO <I>T1</I> (<A href="#6.4 Тип указатель">см.
6.4</A>) может быть объявлен в точке, где <I>T1</I> еще неизвестен. Объявление
<I>T1</I> должно следовать в том же блоке, в котором <I>T</I> является
локальным; </LI>

<LI>Идентификаторы, обозначающие поля записи (<A href="#6.3 Тип запись">см.
6.3</A>) или процедуры, связанные с типом, (<A href="#10.2 Процедуры, связанные с типом">см.
10.2</A>) могут употребляться только в обозначениях записи. </LI>
</OL>

<P>Идентификатор, объявленный в блоке модуля, может сопровождаться при
своем объявлении экспортной меткой (&quot;*&quot; или &quot;-&quot;), чтобы
указать, что он экспортируется. Идентификатор <I>x</I>, экспортируемый
модулем <I>M</I>, может использоваться в других модулях, если они импортируют
<I>M</I> (<A href="#11. Модули">см. гл. 11</A>). Тогда идентификатор обозначается
в этих модулях <I>М.x</I> и называется <I>уточненным идентификатором</I>.
Переменные и поля записей, помеченные знаком &quot;-&quot; в их объявлении,
предназначены <I>только для чтения</I> в модулях-импортерах. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>УточнИдент </TD>

<TD>= </TD>

<TD>[идент &quot;.&quot;] идент.</TD>
</TR>

<TR>
<TD>ИдентОпр</TD>

<TD>= </TD>

<TD>идент [&quot;*&quot; | &quot;-&quot;].</TD>
</TR>
</TABLE>
</UL>

<P>Следующие идентификаторы являются стандартными; их значение определено
в указанных разделах: </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>ABS</TD>

<TD><A href="#10.3">(10.3)</A></TD>

<TD>LEN</TD>

<TD><A href="#len">(10.3)</A></TD>
</TR>

<TR>
<TD>ASH</TD>

<TD><A href="#ash">(10.3)</A></TD>

<TD>LONG</TD>

<TD><A href="#long">(10.3)</A></TD>
</TR>

<TR>
<TD>BOOLEAN   </TD>

<TD><A href="#boolean">(6.1)</A></TD>

<TD>LONGINT</TD>

<TD><A href="#longint">(6.1)</A></TD>
</TR>

<TR>
<TD>CAP</TD>

<TD><A href="#10.3">(10.3)</A>        </TD>

<TD>LONGREAL   </TD>

<TD><A href="#longreal">(6.1)</A></TD>
</TR>

<TR>
<TD>CHAR</TD>

<TD><A href="#char">(6.1)</A></TD>

<TD>MAX</TD>

<TD><A href="#max">(10.3)</A></TD>
</TR>

<TR>
<TD>CHR</TD>

<TD><A href="#chr(">(10.3)</A></TD>

<TD>MIN</TD>

<TD><A href="#min">(10.3)</A></TD>
</TR>

<TR>
<TD>COPY</TD>

<TD><A href="#copy(">(10.3)</A></TD>

<TD>NEW</TD>

<TD><A href="#new">(10.3)</A></TD>
</TR>

<TR>
<TD>DEC</TD>

<TD><A href="#dec">(10.3)</A></TD>

<TD>ODD</TD>

<TD><A href="#odd">(10.3)</A></TD>
</TR>

<TR>
<TD>ENTIER</TD>

<TD><A href="#entier">(10.3)</A></TD>

<TD>ORD</TD>

<TD><A href="#ord">(10.3)</A></TD>
</TR>

<TR>
<TD>EXCL</TD>

<TD><A href="#excl">(10.3)</A></TD>

<TD>REAL</TD>

<TD><A href="#real">(6.1)</A></TD>
</TR>

<TR>
<TD>FALSE</TD>

<TD><A href="#false">(6.1)</A></TD>

<TD>SET</TD>

<TD><A href="#set">(6.1)</A></TD>
</TR>

<TR>
<TD>HALT</TD>

<TD><A href="#halt">(10.3)</A></TD>

<TD>SHORT</TD>

<TD><A href="#short">(10.3)</A></TD>
</TR>

<TR>
<TD>INC</TD>

<TD><A href="#inc">(10.3)</A></TD>

<TD>SHORTINT</TD>

<TD><A href="#shortint">(6.1)</A></TD>
</TR>

<TR>
<TD>INCL</TD>

<TD><A href="#incl">(10.3)</A></TD>

<TD>SIZE</TD>

<TD><A href="#size">(10.3)</A></TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD ALIGN=LEFT VALIGN=TOP>INTEGER</TD>

<TD><A href="#integer">(6.1)</A></TD>

<TD>TRUE</TD>

<TD><A href="#true">(6.1)</A></TD>
</TR>
</TABLE>
</UL>

<H2><A NAME="5. Объявления констант"></A>5. Объявления констант </H2>

<P>Объявление константы связывает ее идентификатор с ее значением. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>ОбъявлениеКонстанты</TD>

<TD> = </TD>

<TD>ИдентОпр &quot;=&quot; КонстантноеВыражение.</TD>
</TR>

<TR>
<TD>КонстантноеВыражение </TD>

<TD> = </TD>

<TD>Выражение.</TD>
</TR>
</TABLE>
</UL>

<P>Константное выражение - это выражение, которое может быть вычислено
по его тексту без фактического выполнения программы. Его операнды - константы
(<A href="#8. Выражения">Гл. 8</A>) или стандартные функции (<A href="#10.3">Гл.
10.3</A>), которые могут быть вычислены во время компиляции. <BR>
Примеры объявлений констант: </P>

<UL>
<P>N = 100 <BR>
limit = 2*N - 1 <BR>
fullSet = {MIN(SET) .. MAX(SET)} </P>
</UL>

<H2><A NAME="6. Объявления типа"></A>6. Объявления типа </H2>

<P>Тип данных определяет набор значений, которые могут принимать переменные
этого типа, и набор применимых операций. Объявление типа связывает идентификатор
с типом. В случае структурированных типов (массивы и записи) объявление
также определяет структуру переменных этого типа. Структурированный тип
не может содержать сам себя. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>ОбъявлениеТипа </TD>

<TD> = </TD>

<TD>ИдентОпр &quot;=&quot; Тип.</TD>
</TR>

<TR>
<TD>Тип</TD>

<TD> = </TD>

<TD>УточнИдент | ТипМассив | ТипЗапись | ТипУказатель | ПроцедурныйТип.</TD>
</TR>
</TABLE>
</UL>

<P><A NAME="Примеры гл.6"></A>Примеры: </P>

<UL>
<P>Table = ARRAY N OF REAL <BR>
<A NAME="Tree"></A>Tree = POINTER TO Node <BR>
Node = RECORD <BR>
     key : INTEGER; <BR>
     left, right: Tree <BR>
END <BR>
CenterTree = POINTER TO CenterNode <BR>
CenterNode = RECORD (Node) <BR>
     width: INTEGER; <BR>
     subnode: Tree <BR>
END <BR>
<A NAME="Function"></A>Function = PROCEDURE(x: INTEGER): INTEGER </P>
</UL>

<H3><A NAME="6.1 Основные типы"></A>6.1 Основные типы </H3>

<P>Основные типы обозначаются стандартными идентификаторами. Соответствующие
операции определены в <A href="#8.2 Операции">8.2</A>, а стандартные функции
в <A href="#10.3">10.3</A>. Предусмотрены следующие основные типы: </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>1. </TD>

<TD><A NAME="BOOLEAN"></A>BOOLEAN         </TD>

<TD>логические значения <A NAME="TRUE"></A>TRUE и <A NAME="FALSE"></A>FALSE</TD>
</TR>

<TR>
<TD>2.</TD>

<TD><A NAME="CHAR"></A>CHAR                 </TD>

<TD>символы расширенного набора ASCII (0X .. 0FFX)</TD>
</TR>

<TR>
<TD>3.</TD>

<TD><A NAME="SHORTINT"></A>SHORTINT        </TD>

<TD>целые в интервале от MIN(SHORTINT) до MAX(SHORTINT)</TD>
</TR>

<TR>
<TD>4.</TD>

<TD><A NAME="INTEGER"></A>INTEGER           </TD>

<TD>целые в интервале от MIN(INTEGER) до MAX(INTEGER)</TD>
</TR>

<TR>
<TD>5.</TD>

<TD><A NAME="LONGINT"></A>LONGINT          </TD>

<TD>целые в интервале от MIN(LONGINT) до MAX(LONGINT)</TD>
</TR>

<TR>
<TD>6.</TD>

<TD><A NAME="REAL"></A>REAL                  </TD>

<TD>вещественные числа в интервале от MIN(REAL) до MAX(REAL)</TD>
</TR>

<TR>
<TD>7.</TD>

<TD><A NAME="LONGREAL"></A>LONGREAL       </TD>

<TD>вещественные числа от MIN(LONGREAL) до MAX(LONGREAL)</TD>
</TR>

<TR>
<TD>8.</TD>

<TD><A NAME="SET"></A>SET                     </TD>

<TD>множество из целых от 0 до MAX(SET)</TD>
</TR>
</TABLE>
</UL>

<P>Типы от 3 до 5 - <I><A href="#Целые">целые типы</A></I>, типы 6 и 7
- <I><A href="#Вещественные">вещественные типы</A></I>, а вместе они называются
<I><A href="#Числовые">числовыми типами</A></I>. Эти типы образуют иерархию;
больший тип <A href="#Поглощение типов"><I>поглощает</I> </A>меньший тип:
</P>

<CENTER><P>LONGREAL &gt;= REAL &gt;= LONGINT &gt;= INTEGER &gt;= SHORTINT
</P></CENTER>

<H3><A NAME="6.2 Тип массив"></A>6.2 Тип массив </H3>

<P>Массив - структура, состоящая из определенного количества элементов
одинакового типа, называемого <I>типом элементов</I>. Число элементов массива
называется его <I>длиной</I>. Элементы массива обозначаются индексами,
которые являются целыми числами от 0 до длины массива минус 1. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>ТипМассив</TD>

<TD> = </TD>

<TD>ARRAY [Длина {&quot;,&quot; Длина}] OF Тип.</TD>
</TR>

<TR>
<TD>Длина</TD>

<TD> = </TD>

<TD>КонстантноеВыражение.</TD>
</TR>
</TABLE>
</UL>

<P>Тип вида </P>

<UL>
<P>ARRAY L0, L1, ..., Ln OF T </P>
</UL>

<P>понимается как сокращение </P>

<UL>
<P>ARRAY L0 OF <BR>
     ARRAY L1 OF<BR>
        ... <BR>
          ARRAY Ln OF T </P>
</UL>

<P>Массивы, объявленные без указания длины, называются <I>открытыми массивами</I>.
Они могут использоваться только в качестве базового типа указателя (<A href="#6.4 Тип указатель">см.
6.4</A>), типа элементов открытых массивов и типа формального параметра
(<A href="#10.1 Формальные параметры">см. 10.1</A>). Примеры: </P>

<UL>
<P>ARRAY 10, N OF INTEGER <BR>
ARRAY OF CHAR </P>
</UL>

<H3><A NAME="6.3 Тип запись"></A>6.3 Тип запись </H3>

<P>Тип запись - структура, состоящая из фиксированного числа элементов,
которые могут быть различных типов и называются <I>полями</I>. Объявление
типа запись определяет имя и тип каждого поля. Область действия идентификаторов
полей простирается от точки их объявления до конца объявления типа запись,
но они также видимы внутри обозначений, ссылающихся на элементы переменных-записей
(<A href="#8.1 Операнды">см. 8.1</A>). Если тип запись экспортируется,
то идентификаторы полей, которые должны быть видимы вне модуля, в котором
объявлены, должны быть помечены. Они называются <I>доступными полями</I>;
непомеченные элементы называются <I>скрытыми полями</I>. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>ТипЗапись</TD>

<TD> = </TD>

<TD>RECORD [&quot;(&quot; БазовыйТип &quot;)&quot;] СписокПолей {&quot;;&quot;
СписокПолей} END.</TD>
</TR>

<TR>
<TD>БазовыйТип</TD>

<TD> = </TD>

<TD>УточнИдент.</TD>
</TR>

<TR>
<TD>СписокПолей </TD>

<TD> = </TD>

<TD>[СписокИдент &quot;:&quot; Тип].</TD>
</TR>
</TABLE>
</UL>

<P>Тип запись может быть объявлен как расширение другого типа запись. В
примере </P>

<UL>
<P>T0 = RECORD x: INTEGER END <BR>
T1 = RECORD (T0) y: REAL END </P>
</UL>

<P><I>T1</I> - (непосредственное) <I><A href="#Расширение типов (базовый тип)">расширение</A></I>
<I>T0</I>, а <I>T0</I> - (непосредственный)<A href="#Расширение типов (базовый тип)">
<I>базовый тип</I></A> <I>T1</I> (см. <A href="#Расширение типов (базовый тип)">Прил.
A</A>). Расширенный тип <I>T1</I> состоит из полей своего базового типа
и полей, которые объявлены в <I>T1</I>. Все идентификаторы, объявленные
в расширенной записи, должны быть отличны от идентификаторов, объявленных
в записи(записях) ее базового типа. </P>

<P>Примеры объявлений типа запись: </P>

<UL>
<P>RECORD <BR>
     day, month, year: INTEGER <BR>
END </P>

<P>RECORD <BR>
     name, firstname: ARRAY 32 OF CHAR; <BR>
     age: INTEGER; <BR>
     salary: REAL <BR>
END </P>
</UL>

<H3><A NAME="6.4 Тип указатель"></A>6.4 Тип указатель </H3>

<P>Переменные-указатели типа <I>P </I>принимают в качестве значений указатели
на переменные некоторого типа <I>T. T </I>называется базовым типом указателя
типа <I>P</I> и должен быть типом массив или запись. Типы указатель заимствуют
отношение расширения своих базовых типов: если тип <I>T1 </I>- расширение<I>
T</I> и <I>P1</I> - это тип POINTER TO <I>T1</I>, то <I>P1</I> также является
расширением<I> P</I>. </P>

<UL>
<P>ТипУказатель = POINTER TO Тип. </P>
</UL>

<P>Если<I> p </I>- переменная типа <I>P </I>= POINTER TO <I>T</I>, вызов
стандартной процедуры <I><A href="#new">NEW(p)</A></I> (<A href="#10.3">см.
10.3</A>) размещает переменную типа <I>T </I>в свободной памяти. Если <I>T</I>
- тип запись или тип массив с фиксированной длиной, размещение должно быть
выполнено вызовом <I>NEW(p)</I>; если тип <I>T</I> - n-мерный открытый
массив, размещение должно быть выполнено вызовом <I>NEW(p, e0, ..., en-1)</I>,
чтобы <I>T </I>был размещен с длинами, заданными выражениями <I>e0, ...,
en-1</I>. В любом случае указатель на размещенную переменную присваивается
<I>p</I>. Переменная <I>p</I> имеет тип <I>P</I>. Переменная <I>p^ </I>(<I>динамическая
переменная</I>), на которую ссылается <I>p,</I> имеет тип <I>T</I>. <BR>
     Любая переменная-указатель может принимать значение NIL, которое не
указывает ни на какую переменную вообще. </P>

<H3><A NAME="6.5 Процедурные типы"></A>6.5 Процедурные типы </H3>

<P>Переменные процедурного типа <I>T</I>, имеют значением процедуру (или
NIL). Если процедура <I>P </I>присваивается переменной типа <I>T</I>, списки
формальных параметров (см. <A href="#10.1 Формальные параметры">Гл. 10.1</A>)
<I>P</I> и <I>T</I> должны <I><A href="#Совпадение списков формальных параметров">совпадать</A></I>
(см. <A href="#Приложение a: Определение терминов">Прил. A</A>). <I>P</I>
не должна быть стандартной или связанной с типом процедурой, и не может
быть локальной в другой процедуре. </P>

<UL>
<P>ПроцедурныйТип = PROCEDURE [ФормальныеПараметры]. </P>
</UL>

<H2><A NAME="7. Объявления переменных"></A>7. Объявления переменных </H2>

<P>Объявления переменных дают описание переменных, определяя идентификатор
и тип данных для них. </P>

<UL>
<P>ОбъявлениеПеременных = СписокИдент &quot;:&quot; Тип. </P>
</UL>

<P>Переменные типа запись и указатель имеют как статический тип (тип, с
которым они объявлены - называемый просто их типом), так и динамический
тип (тип их значения во время выполнения). Для указателей и параметров-переменных
типа запись динамический тип может быть расширением их статического типа.
Статический тип определяет какие поля записи доступны. Динамический тип
используется для вызова связанных с типом процедур (<A href="#10.2 Процедуры, связанные с типом">см. 10.2</A>).
</P>

<P><A NAME="Примеры объявлений"></A>Примеры объявлений переменных (со ссылками
на примеры из <A href="#6. Объявления типа">Гл. 6</A>): </P>

<UL>
<P>i, j, k: INTEGER <BR>
x, y: REAL <BR>
p, q: BOOLEAN <BR>
s: SET <BR>
F: <A href="#function">Function</A> <BR>
a: ARRAY 100 OF REAL <BR>
w: ARRAY 16 OF RECORD <BR>
          name: ARRAY 32 OF CHAR; <BR>
          count: INTEGER <BR>
     END <BR>
t, c: <A href="#tree">Tree</A> </P>
</UL>

<H2><A NAME="8. Выражения"></A>8. Выражения </H2>

<P>Выражения - конструкции, задающие правила вычисления по значениям констант
и текущим значениям переменных других значений путем применения операций
и процедур-функций. Выражения состоят из операндов и операций. Круглые
скобки могут использоваться для группировки операций и операндов. </P>

<H3><A NAME="8.1 Операнды"></A>8.1 Операнды </H3>

<P>За исключением конструкторов множества и литералов (чисел, символьных
констант или строк), операнды представлены обозначениями. Обозначение содержит
идентификатор константы, переменной или процедуры. Этот идентификатор может
быть уточнен именем модуля (см. <A href="#4. Объявления и области действия">Гл.
4</A> и <A href="#11. Модули">11</A>) и может сопровождаться селекторами,
если обозначенный объект - элемент структуры. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=LEFT VALIGN=TOP>
<TD>Обозначение</TD>

<TD> = </TD>

<TD>УточнИдент { &quot;.&quot; идент | &quot;[&quot; СписокВыражений &quot;]&quot;
| &quot;^&quot; | &quot;(&quot; УточнИдент &quot;)&quot; }.</TD>
</TR>

<TR>
<TD>СписокВыражений </TD>

<TD> = </TD>

<TD>Выражение {&quot;,&quot; Выражение}.</TD>
</TR>
</TABLE>
</UL>

<P>Если <I>а</I> - обозначение массива, <I>a[e]</I> означает элемент <I>а</I>,
чей индекс - текущее значение выражения <I>e</I>. Тип <I>e</I> должен быть
целым типом. Обозначение вида <I>a[e0, e1, ..., en]</I> применимо вместо
<I>a[e0] [e1] ... [en]</I>. Если <I>r </I>обозначает запись, то <I>r.f</I>
означает поле <I>f</I> записи <I>r</I> или проце или процедуру <I>f</I>, связанную
с динамическим типом<I> r</I> (<A href="#10.2 Процедуры, связанные с типом">Гл. 10.2</A>).
Если <I>p</I> обозначает указатель, <I>p^</I> означает переменную, на которую
ссылается <I>p</I>. Обозначения <I>p^.f</I> и <I>p^[e]</I> могут быть сокращены
до <I>p.f</I> и <I>p[e]</I>, то есть запись и индекс массива подразумевают
разыменование. Если <I>a</I> или <I>r</I> доступны только для чтения, то
<I>a[e]</I> и <I>r.f </I>также предназначены только для чтения. <BR>
     <I>Охрана типа v(T)</I> требует, чтобы динамическим типом <I>v </I>был
<I>T</I> (или расширение <I>T</I>), то есть выполнение программы прерывается,
если динамический тип <I>v</I> - не <I>T</I> (или расширение <I>T</I>).
В пределах такого обозначения <I>v </I>воспринимается как имеющая статический
тип <I>T</I>. Охрана применима, если </P>

<OL>
<LI><I>v</I> - параметр-переменная типа запись, или <I>v</I> - указатель,
и если </LI>

<LI><I>T</I> - расширение статического типа <I>v</I> </LI>
</OL>

<P>Если обозначенный объект - константа или переменная, то обозначение
ссылается на их текущее значение. Если он - процедура, то обозначение ссылается
на эту процедуру, если только обозначение не сопровождается (возможно пустым)
списком параметров. В последнем случае подразумевается активация процедуры
и подстановка значения результата, полученного при ее исполнении. Фактические
параметры должны соответствовать формальным параметрам как и при вызовах
собственно процедуры (см. <A href="#10.1 Формальные параметры">10.1</A>).
</P>

<P>Примеры обозначений (со ссылками на <A href="#Примеры объявлений">примеры
из Гл. 7</A>): </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>i</TD>

<TD>(INTEGER)</TD>
</TR>

<TR>
<TD>a[i]</TD>

<TD>(REAL)</TD>
</TR>

<TR>
<TD>w[3].name[i]</TD>

<TD>(CHAR)</TD>
</TR>

<TR>
<TD>t.left.right</TD>

<TD>(Tree)</TD>
</TR>

<TR>
<TD>t(CenterTree).subnode    </TD>

<TD>(Tree)</TD>
</TR>
</TABLE>
</UL>

<H3><A NAME="8.2 Операции"></A>8.2 Операции </H3>

<P>В выражениях синтаксически различаются четыре класса операций с разными
приоритетами (порядком выполнения). Операция ~ имеет самый высокий приоритет,
далее следуют операции типа умножения, операции типа сложения и отношения.
Операции одного приоритета выполняются слева направо. Например, x-y-z означает
(x- y) -z. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=LEFT VALIGN=TOP>
<TD>Выражение</TD>

<TD> = </TD>

<TD>ПростоеВыражение [Отношение ПростоеВыражение].</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>ПростоеВыражение</TD>

<TD> = </TD>

<TD>[&quot;+&quot; | &quot;-&quot;] Слагаемое {ОперацияСложения Слагаемое}.</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>Слагаемое</TD>

<TD> = </TD>

<TD>Множитель {ОперацияУмножения Множитель}.</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>Множитель</TD>

<TD> = </TD>

<TD>Обозначение [ФактическиеПараметры] | число | символ | строка | NIL
| Множество | &quot;(&quot; Выражение &quot;)&quot; | &quot;~&quot; Множитель.</TD>
</TR>

<TR>
<TD>Множество</TD>

<TD> = </TD>

<TD>&quot;{&quot; [Элемент {&quot;,&quot; Элемент}] &quot;}&quot;.</TD>
</TR>

<TR>
<TD>Элемент</TD>

<TD> = </TD>

<TD>Выражение [&quot;..&quot; Выражение].</TD>
</TR>

<TR>
<TD>ФактическиеПараметры </TD>

<TD> = </TD>

<TD>&quot;(&quot; [СписокВыражений] &quot;)&quot;.</TD>
</TR>

<TR>
<TD>Отношение</TD>

<TD> = </TD>

<TD>&quot;=&quot; | &quot;#&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot;
| &quot;&gt;&quot; | &quot;&gt;=&quot; | IN | IS.</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>ОперацияСложения</TD>

<TD> = </TD>

<TD>&quot;+&quot; | &quot;-&quot; | OR.</TD>
</TR>

<TR>
<TD>ОперацияУмножения</TD>

<TD> = </TD>

<TD>&quot;*&quot; | &quot;/&quot; | DIV | MOD | &quot;&amp;&quot;.</TD>
</TR>
</TABLE>
</UL>

<P>Предусмотренные операции перечислены в следующих таблицах. Некоторые
операции применимы к операндам различных типов, обозначая разные действия.
В этих случаях фактическая операция определяется типом операндов. Операнды
должны быть <I><A href="#Совместимость выражений">совместимыми выражениями</A></I>
для данной операции (см. <A href="#Приложение a: Определение терминов">Прил.
A</A>). </P>

<H4><A NAME="8.2.1 Логические операции"></A>8.2.1 Логические операции </H4>

<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>OR    </TD>

<TD>логическая дизъюнкция</TD>

<TD>p OR q      </TD>

<TD>&quot;если p, то TRUE, иначе q&quot;</TD>
</TR>

<TR>
<TD>&amp;</TD>

<TD>логическая конъюнкция        </TD>

<TD>p &amp; q</TD>

<TD>&quot;если p то q, иначе FALSE&quot;</TD>
</TR>

<TR>
<TD>~</TD>

<TD>отрицание</TD>

<TD>~p</TD>

<TD>&quot;не p&quot;</TD>
</TR>
</TABLE>

<P>Эти операции применимы к операндам типа BOOLEAN и дают результат типа
BOOLEAN. </P>

<H4><A NAME="8.2.2 Арифметические операции"></A>8.2.2 Арифметические операции
</H4>

<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>+</TD>

<TD>сумма - разность</TD>
</TR>

<TR>
<TD>*</TD>

<TD>произведение</TD>
</TR>

<TR>
<TD>/</TD>

<TD>вещественное деление</TD>
</TR>

<TR>
<TD>DIV</TD>

<TD>деление нацело</TD>
</TR>

<TR>
<TD>MOD   </TD>

<TD>остаток</TD>
</TR>
</TABLE>

<P>Операции +, -, *, и / применимы к операндам <A href="#Числовые">числовых
типов</A>. Тип их результата - тип того операнда, который <A href="#Поглощение типов">поглощает</A>
тип другого операнда, кроме деления (/), чей результат - наименьший <A href="#Вещественные">вещественный
тип</A>, который поглощает типы обоих операндов. При использовании в качестве
одноместной операции &quot;-&quot; обозначает перемену знака, а &quot;+&quot;
- тождественную операцию. Операции DIV и MOD применимы только к <A href="#Целые">целочисленным</A>
операндам. Они связаны следующими формулами, определенными для любого <I>x</I>
и положительного делителя <I>y</I>: </P>

<P>x = (x DIV y) * y + (x MOD y) <BR>
0 &lt; = (x MOD y) &lt; y </P>

<P>Примеры:</P>

<UL>
<TABLE BORDER=1 >
<TR>
<TD>
<CENTER><P>  x  </P></CENTER>
</TD>

<TD>
<CENTER><P>  y  </P></CENTER>
</TD>

<TD>
<CENTER><P>  x DIV y  </P></CENTER>
</TD>

<TD>
<CENTER><P>  x MOD y  </P></CENTER>
</TD>
</TR>

<TR>
<TD>
<CENTER><P>5</P></CENTER>
</TD>

<TD>
<CENTER><P>3</P></CENTER>
</TD>

<TD>
<CENTER><P>1</P></CENTER>
</TD>

<TD>
<CENTER><P>2</P></CENTER>
</TD>
</TR>

<TR>
<TD>
<CENTER><P>-5</P></CENTER>
</TD>

<TD>
<CENTER><P>3</P></CENTER>
</TD>

<TD>
<CENTER><P>-2</P></CENTER>
</TD>

<TD>
<CENTER><P>1</P></CENTER>
</TD>
</TR>
</TABLE>
</UL>

<H4><A NAME="8.2.3 Операции над множествами"></A>8.2.3 Операции над множествами
</H4>

<P>+     объединение <BR>
-      разность (x - y = x * (-y)) <BR>
*      пересечение <BR>
/      симметрическая разность множеств (x / y = (x-y) + (y-x)) </P>

<P>Эти операции применимы к операндам типа SET и дают результат типа SET.
Одноместный &quot;минус&quot; обозначает дополнение <I>x</I>, то есть <I>-x
</I>это множество целых между 0 и MAX(SET), которые не являются элементами
<I>x</I>. Операции с множествами не ассоциативны <I>((a+b)-c # a+(b-c))</I>.
Конструктор множества задает значение множества списком элементов, заключенным
в фигурные скобки. Элементы должны быть целыми в диапазоне 0..MAX(SET).
Диапазон <I>a..b</I> обозначает все целые числа в интервале [a, b]. </P>

<H4><A NAME="8.2.4 Отношения"></A>8.2.4 Отношения </H4>

<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>=</TD>

<TD>равно</TD>
</TR>

<TR>
<TD>#</TD>

<TD>не равно</TD>
</TR>

<TR>
<TD>&lt;</TD>

<TD>меньше</TD>
</TR>

<TR>
<TD>&lt;=    </TD>

<TD>меньшее или равно</TD>
</TR>

<TR>
<TD>&gt;</TD>

<TD>больше</TD>
</TR>

<TR>
<TD>&gt;=</TD>

<TD>больше или равно</TD>
</TR>

<TR>
<TD>IN</TD>

<TD>принадлежность множеству</TD>
</TR>

<TR>
<TD>IS</TD>

<TD>проверка типа</TD>
</TR>
</TABLE>

<P>Отношения дают результат типа BOOLEAN. Отношения =, #, &lt;, &lt;=,
&gt;, и &gt;= применимы к <A href="#Числовые">числовым</A> типам, типу
CHAR, строкам и символьным массивам, содержащим в конце 0X. Отношения =
и # кроме того применимы к типам BOOLEAN и SET, а также к указателям и
процедурным типам (включая значение NIL). <I>x IN s </I>означает &quot;<I>x</I>
является элементом <I>s</I>&quot;. <I>x</I> должен быть целого типа, а
<I>s</I> - типа SET. <I>v IS T</I> означает &quot;динамический тип <I>v
</I>есть <I>T </I>(или расширение <I>T</I>)&quot; и называется <I>проверкой
типа</I>. Проверка типа применима, если </P>

<OL>
<LI><I>v</I> - параметр-переменная типа запись, или <I>v</I> - указатель,
и если </LI>

<LI><I>T</I> - расширение статического типа <I>v</I> </LI>
</OL>

<P>Примеры выражений (со ссылками на <A href="#Примеры объявлений">примеры
из Гл. 7</A>): </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>1991</TD>

<TD>INTEGER</TD>
</TR>

<TR>
<TD>i DIV 3</TD>

<TD>INTEGER</TD>
</TR>

<TR>
<TD>~p OR q</TD>

<TD>BOOLEAN</TD>
</TR>

<TR>
<TD>(i+j) * (i-j)</TD>

<TD>INTEGER</TD>
</TR>

<TR>
<TD>s - {8, 9, 13}</TD>

<TD>SET</TD>
</TR>

<TR>
<TD>i + x</TD>

<TD>REAL</TD>
</TR>

<TR>
<TD>a[i+j] * a[i-j]</TD>

<TD>REAL</TD>
</TR>

<TR>
<TD>(0&lt;=i) &amp; (i&lt;100)</TD>

<TD>BOOLEAN</TD>
</TR>

<TR>
<TD>t.key = 0</TD>

<TD>BOOLEAN</TD>
</TR>

<TR>
<TD>k IN {i..j-1}</TD>

<TD>BOOLEAN</TD>
</TR>

<TR>
<TD>w[i].name &lt;= &quot;John&quot;    </TD>

<TD>BOOLEAN</TD>
</TR>

<TR>
<TD>t IS CenterTree</TD>

<TD>BOOLEAN</TD>
</TR>
</TABLE>
</UL>

<H2><A NAME="9. Операторы"></A>9. Операторы </H2>

<P>Операторы обозначают действия. Есть простые и структурные операторы.
Простые операторы не содержат в себе никаких частей, которые являются самостоятельными
операторами. Простые операторы - присваивание, вызов процедуры, операторы
возврата и выхода. Структурные операторы состоят из частей, которые являются
самостоятельными операторами. Они используются, чтобы выразить последовательное
и условное, выборочное и повторное исполнение. Оператор также может быть
пустым, в этом случае он не обозначает никакого действия. Пустой оператор
добавлен, чтобы упростить правила пунктуации в последовательности операторов.
</P>

<UL>
<P>Оператор = <BR>
     [Присваивание | ВызовПроцедуры <BR>
     | ОператорIf | ОператорCase | ОператорWhile | ОператорRepeat <BR>
     | ОператорFor | ОператорLoop | ОператорWith <BR>
     | EXIT | RETURN [Выражение]]. </P>
</UL>

<H3><A NAME="9.1 Присваивания"></A>9.1 Присваивания </H3>

<P>Присваивание заменяет текущее значение переменной новым значением, определяемым
выражением. Выражение должно быть <A href="#Совместимость по присваиванию">совместимо
по присваиванию</A> с переменной (см. <A href="#Приложение a: Определение терминов">Приложение.
A</A>). Знаком операции присваивания является &quot;:=&quot;, который читается
&quot;присвоить&quot;. </P>

<UL>
<P>Присваивание = Обозначение &quot;:=&quot; Выражение. </P>
</UL>

<P>Если выражение <I>e</I> типа <I>Te</I> присваивается переменной <I>v</I>
типа <I>Tv</I>, имеет место следующее: </P>

<OL>
<LI>Если <I>Tv</I> и <I>Te</I> - записи, то в присваивании участвуют только
те поля <I>Te</I>, которые также имеются в <I>Тv</I> (<I>проецирование</I>);
динамический тип <I>v</I> и статический тип <I>v</I> должны быть <I><A href="#Одинаковые">одинаковы</A></I>,
и не изменяются присваиванием; </LI>

<LI>Если <I>Tv</I> и <I>Te</I> - типы указатель, динамическим типом <I>v</I>
становится динамический тип <I>e</I>; </LI>

<LI>Если <I>Тv</I> это ARRAY <I>n</I> OF CHAR, а <I>e</I> - строка длины
<I>m &lt; n, v[i]</I> присваиваются значения <I>ei </I>для <I>i = 0 .. m-1</I>,
а <I>v[m]</I> получает значение 0X. </LI>
</OL>

<P>Примеры присваиваний (со ссылками на <A href="#Примеры объявлений">примеры
из Гл. 7</A>): </P>

<UL>
<P>i := 0 <BR>
p := i = j <BR>
x := i + 1 <BR>
k := log2(i+j) <BR>
F := log2                            (* см. <A href="#10.1 Формальные параметры">10.1</A>
*) <BR>
s := {2, 3, 5, 7, 11, 13} <BR>
a[i] := (x+y) * (x-y) <BR>
t.key := i <BR>
w[i+1].name := &quot;John&quot; <BR>
t := c </P>
</UL>

<H3><A NAME="9.2 Вызовы процедур"></A>9.2 Вызовы процедур </H3>

<P>Вызов процедуры активирует процедуру. Он может содержать список фактических
параметров, которые заменяют соответствующие формальные параметры, определенные
в объявлении процедуры (см. <A href="#10. Объявления процедур">Гл. 10</A>).
Соответствие устанавливается в порядке следования параметров в списках
фактических и формальных параметров. Имеются два вида параметров: параметры-переменные
и параметры-значения. <BR>
     Если формальный параметр - параметр-переменная, соответствующий фактический
параметр должен быть обозначением переменной. Если фактический параметр
обозначает элемент структурной переменной, селекторы компонент вычисляются,
когда происходит замена формальных параметров фактическими, то есть перед
выполнением процедуры. Если формальный параметр - параметр-значение, соответствующий
фактический параметр должен быть выражением. Это выражение вычисляется
перед вызовом процедуры, а полученное в результате значение присваивается
формальному параметру (см. также <A href="#10.1 Формальные параметры">10.1</A>).
</P>

<UL>
<P>ВызовПроцедуры = Обозначение [ФактическиеПараметры]. </P>
</UL>

<P>Примеры: </P>

<UL>
<P>WriteInt(i*2+1)       (* см. <A href="#10.1 Формальные параметры">10.1</A>
*) <BR>
INC(w[k].count) <BR>
t.Insert(&quot;John&quot;)        (* см. <A href="#11. Модули">11</A> *)
</P>
</UL>

<H3><A NAME="9.3 Последовательность операторов"></A>9.3 Последовательность
операторов </H3>

<P>Последовательность операторов, разделенных точкой с запятой, означает
поочередное выполнение действий, заданных составляющими операторами. </P>

<UL>
<P>ПоследовательностьОператоров = Оператор {&quot;;&quot; Оператор}. </P>
</UL>

<H3><A NAME="9.4 Операторы If"></A>9.4 Операторы If </H3>

<UL>
<P>ОператорIf = <BR>
      IF Выражение THEN ПоследовательностьОператоров <BR>
      {ELSIF Выражение THEN ПоследовательностьОператоров} <BR>
      [ELSE ПоследовательностьОператоров] <BR>
      END. </P>
</UL>

<P>Операторы if задают условное выполнение входящих в них последовательностей
операторов. Логическое выражение, предшествующие последовательности операторов,
будем называть условием (в оригинале - guard. <I>Прим. перев</I>.) Условия
проверяются последовательно одно за другим, пока очередное не окажется
равным TRUE, после чего выполняется связанная с этим условием последовательность
операторов. Если ни одно условие не удовлетворено, выполняется последовательность
операторов, записанная после слова ELSE, если оно имеется. </P>

<P>Пример: </P>

<UL>
<P>IF (ch &gt;= &quot;A&quot;) &amp; (ch &lt;= &quot;Z&quot;) THEN ReadIdentifier
<BR>
ELSIF (ch &gt;= &quot;0&quot;) &amp; (ch &lt;= &quot;9&quot;) THEN ReadNumber
<BR>
ELSIF (ch = &quot; ' &quot;) OR (ch = ' &quot; ') THEN ReadString <BR>
ELSE SpecialCharacter <BR>
END </P>
</UL>

<H3><A NAME="9.5 Операторы Case"></A>9.5 Операторы Case </H3>

<P>Операторы case определяют выбор и выполнение последовательности операторов
по значению выражения. Сначала вычисляется выбирающее выражение, а затем
выполняется та последовательность операторов, чей список меток варианта
содержит полученное значение. Выбирающее выражение должно быть такого <I><A href="#Целые">целого
типа</A></I>, который <I><A href="#Поглощение типов">поглощает</A></I>
типы всех меток вариантов, или и выбирающее выражение и метки вариантов
должны иметь тип CHAR. Метки варианта - константы, и ни одно из их значений
не должно употребляться больше одного раза. Если значение выражения не
совпадает с меткой ни одного из вариантов, выбирается последовательность
операторов после слова ELSE, если оно есть, иначе программа прерывается.
</P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=LEFT VALIGN=TOP>
<TD>ОператорCase</TD>

<TD> = </TD>

<TD>CASE Выражение OF Вариант {&quot; | &quot; Вариант} [ELSE ПоследовательностьОператоров
] END.</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>Вариант</TD>

<TD> = </TD>

<TD>[СписокМетокВарианта &quot;:&quot; ПоследовательностьОператоров].</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>СписокМетокВарианта </TD>

<TD> = </TD>

<TD>МеткиВарианта {&quot;,&quot; МеткиВарианта }.</TD>
</TR>

<TR>
<TD>МеткиВарианта</TD>

<TD> = </TD>

<TD>КонстантноеВыражение [&quot;..&quot; КонстантноеВыражение].</TD>
</TR>
</TABLE>
</UL>

<P>Пример: </P>

<UL>
<P>CASE ch OF <BR>
   &quot;A&quot; .. &quot;Z&quot;: ReadIdentifier <BR>
|  &quot;0&quot; .. &quot;9&quot;: ReadNumber <BR>
|  &quot;'&quot;, '&quot;' : ReadString <BR>
ELSE SpecialCharacter <BR>
END </P>
</UL>

<H3><A NAME="9.6 Операторы While"></A>9.6 Операторы While </H3>

<P>Операторы while задают повторное выполнение последовательности операторов,
пока логическое выражение (условие) остается равным TRUE. Условие проверяется
перед каждым выполнением последовательности операторов. </P>

<UL>
<P>ОператорWhile = WHILE Выражение DO ПоследовательностьОператоров END.
</P>
</UL>

<P>Примеры: </P>

<UL>
<P>WHILE i &gt; 0 DO i := i DIV 2; k := k + 1 END <BR>
WHILE (t # NIL) &amp; (t.key # i) DO t := t.left END </P>
</UL>

<H3><A NAME="9.7 Операторы Repeat"></A>9.7 Операторы Repeat </H3>

<P>Оператор repeat определяет повторное выполнение последовательности операторов
пока условие, заданное логическим выражением, не удовлетворено. Последовательность
операторов выполняется по крайней мере один раз. </P>

<UL>
<P>ОператорRepeat = REPEAT ПоследовательностьОператоров UNTIL Выражение.
</P>
</UL>

<H3><A NAME="9.8 Операторы For"></A>9.8 Операторы For </H3>

<P>Оператор for определяет повторное выполнение последовательности операторов
фиксированное число раз для прогрессии значений целочисленной переменной,
называемой <I>управляющей переменной</I> оператора for. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=LEFT VALIGN=TOP>
<TD>ОператорFor </TD>

<TD>= </TD>

<TD>FOR идент &quot;:=&quot; Выражение TO Выражение [BY КонстантноеВыражение]
DO <BR>
ПоследовательностьОператоров END.</TD>
</TR>
</TABLE>
</UL>

<P>Оператор </P>

<UL>
<P>FOR v := beg TO end BY step DO statements END </P>
</UL>

<P>эквивалентен </P>

<UL>
<P>temp := end; v := beg; <BR>
IF step &gt; 0 THEN <BR>
     WHILE v &lt;= temp DO statements; v := v + step END <BR>
ELSE <BR>
     WHILE v &gt;= temp DO statements; v := v + step END <BR>
END </P>
</UL>

<P><I>temp</I> и <I>v</I> имеют <I><A href="#Одинаковые">одинаковый</A></I>
тип. Шаг (<I>step</I>) должен быть отличным от нуля константным выражением.
Если шаг не указан, он предполагается равным 1. </P>

<P>Примеры:</P>

<UL>
<P>FOR i := 0 TO 79 DO k := k + a[i] END <BR>
FOR i := 79 TO 1 BY -1 DO a[i] := a[i-1] END </P>
</UL>

<H3><A NAME="9.9 Операторы Loop"></A>9.9 Операторы Loop </H3>

<P>Оператор loop определяет повторное выполнение последовательности операторов.
Он завершается после выполнения оператора выхода внутри этой последовательности
(см. <A href="#9.10 Операторы возврата и выхода">9.10</A>). </P>

<UL>
<P>ОператорLoop = LOOP ПоследовательностьОператоров END. </P>
</UL>

<P>Пример: </P>

<UL>
<P>LOOP <BR>
     ReadInt(i); <BR>
     IF i &lt; 0 THEN EXIT END; <BR>
     WriteInt(i) <BR>
END </P>
</UL>

<P>Операторы loop полезны, чтобы выразить повторения с несколькими точками
выхода, или в случаях, когда условие выхода находится в середине повторяемой
последовательности операторов. </P>

<H3><A NAME="9.10 Операторы возврата и выхода"></A>9.10 Операторы возврата
и выхода </H3>

<P>Оператор возврата выполняет завершение процедуры. Он обозначается словом
RETURN, за которым следует выражение, если процедура является процедурой-функцией.
Тип выражения должен быть <I><A href="#Совместимость по присваиванию">совместим
по присваиванию</A></I> (см. <A href="#Приложение a: Определение терминов">Приложение
A</A>) с типом результата, определенным в заголовке процедуры (см. <A href="#10. Объявления процедур">Гл.
10</A>). <BR>
     Процедуры-функции должны быть завершены оператором возврата, задающим
значение результата. В собственно процедурах оператор возврата подразумевается
в конце тела процедуры. Любой явный оператор появляется, следовательно,
как дополнительная (вероятно, для исключительной ситуации) точка завершения.
<BR>
     Оператор выхода обозначается словом EXIT. Он определяет завершение
охватывающего оператора loop и продолжение выполнения программы с оператора,
следующего за оператором loop. Оператор выхода связан с содержащим его
оператором loop контекстуально, а не синтаксически. </P>

<H3><A NAME="9.11 Операторы With"></A>9.11 Операторы With </H3>

<P>Операторы with выполняют последовательность операторов в зависимости
от результата проверки типа и применяют охрану типа к каждому вхождению
проверяемой переменной внутри этой последовательности операторов. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=LEFT VALIGN=TOP>
<TD>ОператорWith  </TD>

<TD> = </TD>

<TD>WITH Охрана DO ПоследовательностьОператоров {&quot;|&quot; Охрана DO
ПоследовательностьОператоров} [ELSE ПоследовательностьОператоров] END.</TD>
</TR>

<TR>
<TD>Охрана</TD>

<TD> = </TD>

<TD>УточнИдент &quot;:&quot; УточнИдент.</TD>
</TR>
</TABLE>
</UL>

<P>Если <I>v</I> - параметр-переменная типа запись или переменная-указатель,
и если ее статический тип <I>T0</I>, оператор </P>

<UL>
<P>WITH v: T1 DO S1 | v: T2 DO S2 ELSE S3 END </P>
</UL>

<P>имеет следующий смысл: если динамический тип <I>v - T1</I>, то выполняется
последовательность операторов <I>S1 </I>в которой <I>v</I> воспринимается
так, будто она имеет статический тип <I>T1</I>; иначе, если динамический
тип <I>v - T2</I>, выполняется <I>S2</I>, где <I>v</I> воспринимается как
имеющая статический тип <I>T2</I>; иначе выполняется <I>S3</I>. <I>T1</I>
и <I>T2</I> должны быть расширениями <I>T0</I>. Если ни одна проверка типа
не удовлетворена, а ELSE отсутствует, программа прерывается. </P>

<P>Пример: </P>

<UL>
<P>WITH t: CenterTree DO i := t.width; c := t.subnode END </P>
</UL>

<H2><A NAME="10. Объявления процедур"></A>10. Объявления процедур </H2>

<P>Объявление процедуры состоит из <I>заголовка процедуры</I> и <I>тела
процедуры</I>. Заголовок определяет имя процедуры и <I><A href="#10.1 Формальные параметры">формальные
параметры</A></I>. Для связанных с типом процедур в объявлении также определяется
параметр-приемник. Тело содержит объявления и операторы. Имя процедуры
повторяется в конце объявления процедуры. <BR>
     Имеются два вида процедур: <I>собственно процедуры</I> и <I>процедуры-
функции</I>. Последние активизируются обозначением функции как часть выражения
и возвращают результат, который является операндом выражения. Собственно
процедуры активизируются вызовом процедуры. Процедура является процедурой-функцией,
если ее формальные параметры задают тип результата. Тело процедуры-функции
должно содержать оператор возврата, который определяет результат. <BR>
     Все константы, переменные, типы и процедуры, объявленные внутри тела
процедуры, <I>локальны</I> в процедуре. Поскольку процедуры тоже могут
быть объявлены как локальные объекты, объявления процедур могут быть вложенными.
Вызов процедуры изнутри ее объявления подразумевает рекурсивную активацию.
<BR>
     Объекты, объявленные в окружении процедуры, также видимы в тех частях
процедуры, в которых они не перекрыты локально объявленным объектом с тем
же самым именем. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR VALIGN=TOP>
<TD>ОбъявлениеПроцедуры     </TD>

<TD> = </TD>

<TD>ЗаголовокПроцедуры &quot;;&quot; ТелоПроцедуры идент.</TD>
</TR>

<TR VALIGN=TOP>
<TD>ЗаголовокПроцедуры</TD>

<TD> = </TD>

<TD>PROCEDURE [Приемник] ИдентОпр [ФормальныеПараметры].</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>ТелоПроцедуры</TD>

<TD> = </TD>

<TD>ПоследовательностьОбъявлений [BEGIN ПоследовательностьОператоров] END.</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>ПослОбъявлений</TD>

<TD> = </TD>

<TD>{CONST {ОбъявлениеКонстант &quot;;&quot;} | TYPE{ОбъявлениеТипов &quot;;&quot;}
| VAR {ОбъявлениеПеременных &quot;;&quot;}} {ОбъявлениеПроцедуры &quot;;&quot;
| ОпережающееОбъявление&quot;;&quot;}.</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>ОпережающееОбъявление </TD>

<TD> = </TD>

<TD>PROCEDURE&quot;^&quot; [Приемник] ИдентОпр [ФормальныеПараметры].</TD>
</TR>
</TABLE>
</UL>

<P>Если объявление процедуры содержит параметр-приемник, процедура рассматривается
как связанная с типом (см. <A href="#10.2 Процедуры, связанные с типом">10.2</A>).
<I>Опережающее объявление</I> служит чтобы разрешить ссылки на процедуру,
чье фактическое объявление появляется в тексте позже. Списки формальных
параметров опережающего объявления и фактического объявления должны быть
идентичны. </P>

<H3><A NAME="10.1 Формальные параметры"></A>10.1 Формальные параметры </H3>

<P>Формальные параметры - идентификаторы, объявленные в списке формальных
параметров процедуры. Им соответствуют фактические параметры, которые задаются
при вызове процедуры. Подстановка фактических параметров вместо формальных
происходит при вызове процедуры. Имеются два вида параметров: <I>параметры-значения</I>
и <I>параметры-переменные</I>, обозначаемые в списке формальных параметров
отсутствием или наличием ключевого слова VAR. Параметры-значения это локальные
переменные, которым в качестве начального присваивается значение соответствующего
фактического параметра. Параметры-переменные соответствуют фактическим
параметрам, которые являются переменными, и означают эти переменные. Область
действия формального параметра простирается от его объявления до конца
блока процедуры, в котором он объявлен. Процедура-функция без параметров
должна иметь пустой список параметров. Она должна вызываться обозначением
функции, чей список фактических параметров также пуст. Тип результата процедуры
не может быть ни записью, ни массивом. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=LEFT VALIGN=TOP>
<TD>ФормальныеПараметры </TD>

<TD> = </TD>

<TD>&quot;(&quot; [СекцияФП {&quot;;&quot; СекцияФП }] &quot;)&quot; [&quot;:&quot; УточненныйИдент].</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>СекцияФП</TD>

<TD> = </TD>

<TD>[VAR] идент {&quot;,&quot; идент} &quot;:&quot; Тип.</TD>
</TR>
</TABLE>
</UL>

<P>Пусть <I>Tf</I> - тип формального параметра <I>f</I> (не открытого массива)
и <I>Ta</I> - тип соответствующего фактического параметра <I>a</I>. Для
параметров-переменных <I>Ta</I> и <I>Tf </I>должны быть одинаковыми типами
или <I>Tf </I>должен быть типом запись, а <I>Ta</I> - расширением <I>Tf.</I>
Для параметров-значений <I>а</I> должен быть <I><A href="#Совместимость по присваиванию">совместим
по присваиванию</A></I> с <I>f </I>(см. <A href="#Приложение a: Определение терминов">Прил.
A</A>). <BR>
     Если <I>Tf </I>- открытый массив, то a должен быть <I><A href="#Совместимость массивов">совместимым
массивом</A></I> для <I>f</I> (см. <A href="#Приложение a: Определение терминов">Прил.
A</A>). Длина <I>f</I> становится равной длине <I>a</I>.</P>

<P>Примеры объявлений процедур: </P>

<UL>
<P>PROCEDURE ReadInt (VAR x: INTEGER); <BR>
     VAR i: INTEGER; ch: CHAR; <BR>
BEGIN i := 0; Read(ch); <BR>
     WHILE (&quot;0&quot; &lt;= ch) &amp; (ch &lt;= &quot;9&quot;) DO <BR>
           i := 10*i + (ORD(ch)-ORD(&quot;0&quot;)); Read(ch) <BR>
     END; <BR>
     x := i <BR>
END ReadInt </P>

<P>PROCEDURE WriteInt (x: INTEGER); (*0 &lt;= x &lt;100000*) <BR>
     VAR i: INTEGER; buf: ARRAY 5 OF INTEGER; <BR>
BEGIN i := 0; <BR>
     REPEAT buf[i] := x MOD 10; x := x DIV 10; INC(i) UNTIL x = 0; <BR>
     REPEAT DEC(i); Write(CHR(buf[i] + ORD(&quot;0&quot;))) UNTIL i = 0
<BR>
END WriteInt </P>

<P>PROCEDURE WriteString (s: ARRAY OF CHAR); <BR>
     VAR i: INTEGER; <BR>
BEGIN i := 0; <BR>
     WHILE (i &lt; LEN(s)) &amp; (s[i] # 0X) DO Write(s[i]); INC(i) END
<BR>
END WriteString; </P>

<P>PROCEDURE log2 (x: INTEGER): INTEGER; <BR>
     VAR y: INTEGER; (*предполагается x&gt;0*) <BR>
BEGIN <BR>
     y := 0; WHILE x &gt; 1 DO x := x DIV 2; INC(y) END; <BR>
     RETURN y <BR>
END log2 </P>
</UL>

<H3><A NAME="10.2 Процедуры, связанные с типом"></A>10.2 Процедуры, связанные
с типом </H3>

<P>Глобально объявленные процедуры могут быть ассоциированы с типом запись,
объявленным в том же самом модуле. В этом случае говорится, что процедуры
<I>связаны</I> с типом запись. Связь выражается типом <I>приемника</I>
в заголовке объявления процедуры. Приемник может быть или параметром-переменной
типа <I>Т</I>, если <I>Т</I> - тип запись, или параметром-значением типа
POINTER TO <I>T</I> (где <I>T</I> - тип запись). Процедура, связанная с
типом <I>T</I>, рассматривается как локальная для него. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR VALIGN=TOP>
<TD>ЗаголовокПроцедуры </TD>

<TD> = </TD>

<TD>PROCEDURE [Приемник] ИдентОпр [ФормальныеПараметры].</TD>
</TR>

<TR VALIGN=TOP>
<TD>Приемник</TD>

<TD> = </TD>

<TD>&quot;(&quot; [VAR] имя &quot;:&quot; имя &quot;)&quot;.</TD>
</TR>
</TABLE>
</UL>

<P>Если процедура <I>P</I> связана с типом <I>T0</I>, она неявно также
связана с любым типом <I>T1</I>, который является расширением <I>T0</I>.
Однако процедура <I>P' </I>(с тем же самым именем что и <I>P</I>) может
быть явно связана с <I>T1</I>, перекрывая в этом случае связывание c <I>P</I>.
<I>P'</I> рассматривается как <I>переопределение</I> <I>P</I> для <I>T1</I>.
Формальные параметры <I>P</I> и <I>P'</I> должны <I><A href="#Совпадение списков формальных параметров">совпадать</A></I>
(см. <A href="#Приложение a: Определение терминов">Прил. A</A>). Если <I>P
</I>и <I>T1</I> экспортируются (см. <A href="#4. Объявления и области действия">Главу
4</A>), <I>P'</I> также должна экспортироваться. <BR>
Если <I>v</I> - обозначение, а <I>P</I> - связанная процедура, то<I> v.P</I>
обозначает процедуру <I>P</I>, связанную с динамическим типом <I>v</I>.
Заметим, что это может быть процедура, отличная от той, что связана со
статическим типом<I> v</I>. <I>v</I> передается приемнику процедуры <I>P</I>
согласно правилам передачи параметров, определенным в <A href="#10.1 Формальные параметры">Главе
10.1</A>. <BR>
Если <I>r</I> - параметр-приемник, объявленный с типом <I>T, r.P^</I> обозначает
(переопределенную) процедуру <I>P</I>, связанную с базовым для <I>T</I>
типом. В опережающем объявлении связанной процедуры и в фактическом объявлении
процедуры параметр-приемник должен иметь <I><A href="#Одинаковые">одинаковый</A></I>
тип. Списки формальных параметров в обоих объявлениях должны быть идентичны.
</P>

<P>Примеры:</P>

<UL>
<P>PROCEDURE (t: Tree) Insert (node: Tree); <BR>
     VAR p, father: Tree; <BR>
BEGIN p := t; <BR>
     REPEAT father := p; <BR>
          IF node.key = p.key THEN RETURN END; <BR>
          IF node.key &lt; p.key THEN p := p.left ELSE p := p.right END
<BR>
     UNTIL p = NIL; <BR>
     IF node.key &lt; father.key THEN father.left := node ELSE father.right
:= node END; <BR>
     node.left := NIL; node.right := NIL <BR>
END Insert; </P>

<P>PROCEDURE (t: CenterTree) Insert (node: Tree); (*пPROCEDURE (t: CenterTree) Insert (node: Tree); (*переопределение*) <BR>
BEGIN <BR>
     WriteInt(node(CenterTree).width); <BR>
     t.Insert^ (node) (* вызывает процедуру Insert, связанную с Tree *)
<BR>
END Insert;</P>
</UL>

<H3><A NAME="10.3"></A>10.3 Стандартные процедуры </H3>

<P>Следующая таблица содержит список стандартных процедур. Некоторые процедуры
- обобщенные, то есть они применимы к операндам нескольких типов. Буква
<I>v</I> обозначает переменную, <I>x</I> и <I>n </I>- выражения, <I>T</I>
- тип. </P>

<P><I>Процедуры-функции </I></P>

<TABLE BORDER=1 >
<TR ALIGN=CENTER>
<TD>Название </TD>

<TD>Тип аргумента</TD>

<TD>Тип результата</TD>

<TD>Функция </TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="ABS(x)"></A>ABS(x) </TD>

<TD>числовой тип</TD>

<TD>совпадает с типом x   </TD>

<TD>абсолютное значение</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="ASH"></A>ASH(x, n) </TD>

<TD>x, n: целый тип</TD>

<TD>LONGINT</TD>

<TD>арифметический сдвиг (x*2<SUP>n</SUP>)</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="CAP"></A>CAP(x) </TD>

<TD>CHAR</TD>

<TD>CHAR</TD>

<TD>x - буква: соответствующая заглавная буква</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="CHR("></A>CHR(x) </TD>

<TD>целый тип</TD>

<TD>CHAR</TD>

<TD>символ с порядковым номером x</TD>
</TR>

<TR>
<TD><A NAME="ENTIER"></A>ENTIER(x) </TD>

<TD>вещественный тип</TD>

<TD>LONGINT</TD>

<TD>наибольшее целое, не превосходящее x</TD>
</TR>

<TR>
<TD><A NAME="LEN"></A>LEN(v, n) </TD>

<TD>v: массив; n: целая константа  </TD>

<TD>LONGINT</TD>

<TD>длина v в измерении n (первое измерение = 0)</TD>
</TR>

<TR>
<TD>LEN(v) </TD>

<TD>v: массив</TD>

<TD>LONGINT</TD>

<TD>равносильно LEN(v, 0)</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="LONG"></A>LONG(x) </TD>

<TD>SHORTINT<BR>
INTEGER<BR>
REAL</TD>

<TD>INTEGER<BR>
LONGINT<BR>
LONGREAL</TD>

<TD>тождество</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="MAX"></A>MAX(T) </TD>

<TD>T = основной тип<BR>
T = SET</TD>

<TD>T <BR>
INTEGER</TD>

<TD>наибольшее значение типа T<BR>
наибольший элемент множества</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="MIN"></A>MIN(T) </TD>

<TD>T = основной тип<BR>
T = SET</TD>

<TD>T<BR>
INTEGER</TD>

<TD>наименьшее значение типа T<BR>
0</TD>
</TR>

<TR>
<TD><A NAME="ODD"></A>ODD(x) </TD>

<TD>целый тип</TD>

<TD>BOOLEAN</TD>

<TD>x MOD 2 = 1</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="ORD"></A>ORD(x) </TD>

<TD>CHAR</TD>

<TD>INTEGER</TD>

<TD>порядковый номер x</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="SHORT"></A>SHORT(x) </TD>

<TD>LONGINT<BR>
INTEGER<BR>
LONGREAL</TD>

<TD>INTEGER<BR>
SHORTINT<BR>
REAL</TD>

<TD>тождество<BR>
тождество<BR>
тождество (возможно усечение)</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="SIZE"></A>SIZE(T) </TD>

<TD>любой тип</TD>

<TD>целый тип</TD>

<TD>число байт, занимаемых T</TD>
</TR>
</TABLE>

<P><I>Собственно процедуры </I></P>

<TABLE BORDER=1 >
<TR>
<TD>
<CENTER><P>Название </P></CENTER>
</TD>

<TD>
<CENTER><P>Типы аргументов</P></CENTER>
</TD>

<TD>
<CENTER><P>Функция</P></CENTER>
</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="ASSERT"></A>ASSERT(x) </TD>

<TD>x: логическое выражение</TD>

<TD>прерывает выполнение программы, если не x</TD>
</TR>

<TR VALIGN=TOP>
<TD>ASSERT(x, n) </TD>

<TD>x: логическое выражение; n:целая константа</TD>

<TD>прерывает выполнение программы, если не x</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="COPY("></A>COPY(x, v) </TD>

<TD>x: символьный массив, строка; v: символьный массив</TD>

<TD>v := x</TD>
</TR>

<TR>
<TD><A NAME="DEC"></A>DEC(v) </TD>

<TD>целый тип</TD>

<TD>v := v - 1</TD>
</TR>

<TR>
<TD><A NAME="DEC"></A>DEC(v, n) </TD>

<TD>v, n: целый тип</TD>

<TD>v := v - n</TD>
</TR>

<TR>
<TD><A NAME="EXCL"></A>EXCL(v, x) </TD>

<TD>v: SET; x: целый тип</TD>

<TD>v := v - {x}</TD>
</TR>

<TR>
<TD><A NAME="HALT"></A>HALT(n) </TD>

<TD>целая константа</TD>

<TD>прерывает выполнение программы</TD>
</TR>

<TR>
<TD><A NAME="INC"></A>INC(v) </TD>

<TD>целый тип</TD>

<TD>v := v + 1</TD>
</TR>

<TR>
<TD>INC(v, n) </TD>

<TD>v, n: целый тип</TD>

<TD>v := v + n</TD>
</TR>

<TR>
<TD><A NAME="INCL"></A>INCL(v, x) </TD>

<TD>v: SET; x: целый тип</TD>

<TD>v := v + {x}</TD>
</TR>

<TR VALIGN=TOP>
<TD><A NAME="NEW"></A>NEW(v) </TD>

<TD>указатель на запись или массив фиксированной длины</TD>

<TD>размещает v ^</TD>
</TR>

<TR>
<TD>NEW(v, x0, ..., xn)  </TD>

<TD>v: указатель на открытый массив; xi: целый тип</TD>

<TD>размещает v^ с длинами x0.. xn</TD>
</TR>
</TABLE>

<P>COPY разрешает присваивание строки или символьного массива, содержащего
ограничитель 0X, другому символьному массиву. В случае необходимости, присвоенное
значение усекается до длины получателя минус один. Получатель всегда будет
содержать 0X как ограничитель. В ASSERT(x, n) и HALT(n), интерпретация
n зависит от реализации основной системы. </P>

<H2><A NAME="11. Модули"></A>11. Модули </H2>

<P>Модуль - совокупность объявлений констант, типов, переменных и процедур
вместе с последовательностью операторов, предназначенных для присваивания
начальных значений переменным. Модуль представляет собой текст, который
является единицей компиляции. </P>

<UL>
<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR VALIGN=TOP>
<TD>Модуль</TD>

<TD> = </TD>

<TD>MODULE идент &quot;;&quot; [СписокИмпорта] ПоследовательностьОбъявлений
<BR>
[BEGIN ПоследовательностьОператоров] END идент &quot;.&quot;.</TD>
</TR>

<TR>
<TD>СписокИмпорта </TD>

<TD> = </TD>

<TD>IMPORT Импорт {&quot;,&quot; Импорт} &quot;;&quot;.</TD>
</TR>

<TR>
<TD>Импорт</TD>

<TD> = </TD>

<TD>[идент &quot;:=&quot;] идент.</TD>
</TR>
</TABLE>
</UL>

<P>Список импорта определяет имена импортируемых модулей. Если модуль <I>A</I>
импортируется модулем <I>M</I>, и <I>A</I> экспортирует идентификатор <I>x</I>,
то <I>x</I> упоминается внутри <I>M</I> как <I>A.x</I>. Если <I>A </I>импортируется
как <I>B:=A</I>, объект <I>x</I> должен вызываться как <I>B.x</I>. Это
позволяет использовать короткие имена-псевдонимы в уточненных идентификаторах.
Модуль не должен импортировать себя. Идентификаторы, которые экспортируются
(то есть должны быть видимы в модулях-импортерах) нужно отметить экспортной
меткой в их объявлении (см. <A href="#4. Объявления и области действия">Главу 4</A>).
<BR>
     Последовательность операторов после символа BEGIN выполняется, когда
модуль добавляется к системе (загружается). Это происходит после загрузки
импортируемых модулей. Отсюда следует, тот циклический импорт модулей запрещен.
Отдельные (не имеющие параметров и экспортированные) процедуры могут быть
активированы из системы. Эти процедуры служат <I>командами</I> (см. <A href="#d1. Команды">Приложение
D1</A>). </P>

<UL>
<P><A NAME="MODULE Trees"></A>MODULE Trees; (* экспорт: Tree, Node, Insert,
Search, Write, Init *) <BR>
     IMPORT Texts, Oberon; (* экспорт только для чтения: Node.name *) </P>

<P>     TYPE <BR>
          Tree* = POINTER TO Node; <BR>
          Node* = RECORD <BR>
               name-: POINTER TO ARRAY OF CHAR; <BR>
               left, right: Tree <BR>
          END; </P>

<P>     VAR w: Texts.Writer; </P>

<P>     PROCEDURE (t: Tree) Insert* (name: ARRAY OF CHAR); <BR>
          VAR p, father: Tree; <BR>
     BEGIN p := t; <BR>
          REPEAT father := p; <BR>
               IF name = p.name^ THEN RETURN END; <BR>
               IF name &lt; p.name^ THEN p := p.left ELSE p := p.right
END <BR>
          UNTIL p = NIL; <BR>
          NEW(p); p.left := NIL; p.right := NIL; NEW(p.name, LEN(name)+1);
COPY(name, p.name^); <BR>
          IF name &lt; father.name^ THEN father.left := p ELSE father.right
:= p END <BR>
     END Insert; </P>

<P>     PROCEDURE (t: Tree) Search* (name: ARRAY OF CHAR): Tree; <BR>
          VAR p: Tree; <BR>
     BEGIN p := t; <BR>
          WHILE (p # NIL) &amp; (name # p.name^) DO <BR>
               IF name &lt; p.name^ THEN p := p.left ELSE p := p.right
END <BR>
          END; <BR>
          RETURN p <BR>
     END Search; </P>

<P>     PROCEDURE (t: Tree) Write*; <BR>
     BEGIN <BR>
           IF t.left # NIL THEN t.left.Write END; <BR>
           Texts.WriteString(w, t.name^); Texts.WriteLn(w); Texts.Append(Oberon.Log,
w.buf); <BR>
           IF t.right # NIL THEN t.right.Write END <BR>
     END Write; </P>

<P>     PROCEDURE Init* (t: Tree); <BR>
     BEGIN NEW(t.name, 1); t.name[0] := 0X; t.left := NIL; t.right := NIL
<BR>
     END Init; </P>

<P>BEGIN Texts.OpenWriter(w) <BR>
END Trees. </P>
</UL>

<H2><A NAME="Приложение A: Определение терминов"></A>Приложение A: Определение
терминов </H2>

<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD><A NAME="Целые"></A><B>Целые типы</B>                     </TD>

<TD>SHORTINT, INTEGER, LONGINT</TD>
</TR>

<TR>
<TD><A NAME="Вещественные"></A><B>Вещественные типы</B>      </TD>

<TD>REAL, LONGREAL</TD>
</TR>

<TR>
<TD><A NAME="Числовые"></A><B>Числовые типы</B>               </TD>

<TD>Целые типы, вещественные типы</TD>
</TR>
</TABLE>

<H4><A NAME="Одинаковые"></A>Одинаковые типы </H4>

<P>Две переменные <I>a</I> и <I>b</I> с типами <I>Ta</I> и <I>Tb</I> имеют
<I>одинаковый</I> тип, если </P>

<OL>
<LI><I>Ta </I>и <I>Tb</I> оба обозначены одним и тем же идентификатором
типа, или </LI>

<LI><I>Ta</I> объявлен равным <I>Tb</I> в объявлении типа вида <I>Ta =
Tb</I>, или </LI>

<LI><I>a</I> и <I>b </I>появляются в одном и том же списке идентификаторов
переменных, полей записи или объявлении формальных параметров и не являются
открытыми массивами. </LI>
</OL>

<H4><A NAME="Равные типы"></A>Равные типы </H4>

<P>Два типа <I>Ta</I>, и <I>Tb</I> <I>равны</I>, если </P>

<OL>
<LI><I>Ta</I> и <I>Tb</I> - <I><A href="#Одинаковые">одинаковые</A></I>
типы, или </LI>

<LI><I>Ta</I> и <I>Tb</I> - типы открытый массив с <I>равными</I> типами
элементов, или </LI>

<LI><I>Ta</I> и <I>Tb</I> - процедурные типы, чьи списки формальных параметров
<I><A href="#Совпадение списков формальных параметров">совпадают</A></I>.
</LI>
</OL>

<H4><A NAME="Поглощение типов"></A>Поглощение типов </H4>

<P>Числовые типы <I>поглощают</I> (значения) меньших числовых типов согласно
следующей иерархии: <BR>
     LONGREAL &gt;= REAL &gt;= LONGINT &gt;= INTEGER &gt;= SHORTINT </P>

<H4><A NAME="Расширение типов (базовый тип)"></A>Расширение типов (базовый
тип) </H4>

<P>В объявлении типа <I>Tb = RECORD (Ta) ... END, Tb</I> - <I>непосредственное
расширение</I> <I>Ta</I>, а <I>Ta</I> - <I>непосредственный базовый тип</I>
<I>Tb</I>. Тип <I>Tb</I> есть расширение типа <I>Ta</I> (<I>Ta </I>есть
базовый тип <I>Tb</I>) если </P>

<OL>
<LI><I>Ta</I> и <I>Tb</I> - <I><A href="#Одинаковые">одинаковые</A></I>
типы, или </LI>

<LI><I>Tb - непосредственное расширение</I> типа, являющегося <I>расширением
Ta</I> </LI>
</OL>

<P>Если <I>Pa = POINTER TO Ta</I> и <I>Pb = POINTER TO Tb</I>, то <I>Pb</I>
есть <I>расширение</I> <I>Pa</I> (<I>Pa</I> есть <I>базовый тип</I> <I>Pb</I>),
если <I>Tb</I> есть <I>расширение</I> <I>Ta</I>. </P>

<H4><A NAME="Совместимость по присваиванию"></A>Совместимость по присваиванию
</H4>

<P>Выражение <I>e</I> типа <I>Te</I> <I>совместимо по присваиванию</I>
с переменной <I>v</I> типа <I>Tv</I>, если выполнено одно из следующих
условий: </P>

<OL>
<LI><I>Te</I> и <I>Tv</I> - <I><A href="#Одинаковые">одинаковые</A></I>
типы; </LI>

<LI><I>Te</I> и <I>Tv</I> - числовые типы и <I>Tv</I> <I><A href="#Поглощение типов">поглощает</A></I>
<I>Te</I>; </LI>

<LI><I>Te</I> и <I>Tv</I> - типы запись, <I>Te</I> есть <I><A href="#Расширение типов (базовый тип)">расширение</A></I>
<I>Tv</I>, а <I>v</I> имеет динамический тип <I>Tv</I>; </LI>

<LI><I>Te </I>и <I>Tv</I> - типы указатель и <I>Te</I> - <I><A href="#Расширение типов (базовый тип)">расширение</A></I>
<I>Tv</I>; </LI>

<LI><I>Tv</I> - тип указатель или процедурный тип, а <I>e</I> - NIL; </LI>

<LI><I>Tv</I> - ARRAY <I>n</I> OF CHAR, <I>e</I> - строковая константа
из <I>m</I> символов и <I>m &lt; n</I>; </LI>

<LI><I>Tv</I> - процедурный тип, а <I>e</I> - имя процедуры, чьи формальные
параметры <I><A href="#Совпадение списков формальных параметров">совпадают</A></I>
с параметрами <I>Tv</I>. </LI>
</OL>

<H4><A NAME="Совместимость массивов"></A>Совместимость массивов </H4>

<P>Фактический параметр<I> a</I> типа <I>Ta</I> является совместимым массивом
для формального параметра<I> f</I> типа <I>Tf </I>если </P>

<OL>
<LI><I>Tf</I> и <I>Ta</I> - <I><A href="#Одинаковые">одинаковые</A></I>
типы или </LI>

<LI><I>Tf</I> - открытый массив, <I>Ta</I> - любой массив, а типы их элементов
- <I>совместимые массивы</I> или </LI>

<LI><I>f </I>- параметр-значение типа ARRAY OF CHAR, а фактический параметр
<I>a</I> - строка. </LI>
</OL>

<H4><A NAME="Совместимость выражений"></A>Совместимость выражений </H4>

<P>Для данной операции операнды являются <I>совместимыми выражениями</I>,
если их типы соответствуют следующей таблице (в который указан также тип
результата выражения). Символьные массивы, которые сравниваются, должны
содержать в качестве ограничителя 0X. Тип T1 должен быть расширением типа
T0: </P>

<TABLE BORDER=1 >
<TR ALIGN=CENTER VALIGN=CENTER>
<TD><I>операция </I></TD>

<TD><I>первый операнд</I></TD>

<TD ALIGN=CENTER><I>второй операнд</I></TD>

<TD><I>тип результата</I></TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>+ - * </TD>

<TD><I><A href="#Числовые">числовой</A></I></TD>

<TD><I><A href="#Числовые">числовой</A></I></TD>

<TD>наименьший <I><A href="#Числовые">числовой</A></I> тип, <A href="#Поглощение типов">поглощающий</A>
оба операнда</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>/ </TD>

<TD><I><A href="#Числовые">числовой</A></I></TD>

<TD><I><A href="#Числовые">числовой</A></I></TD>

<TD>наименьший <I><A href="#Вещественные">вещественный</A></I> тип, <A href="#Поглощение типов">поглощающий</A>
оба операнда</TD>
</TR>

<TR>
<TD>+ - * / </TD>

<TD>SET </TD>

<TD>SET</TD>

<TD>SET</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>DIV MOD </TD>

<TD><I><A href="#Целые">целый</A></I></TD>

<TD><I><A href="#Целые">целый</A></I></TD>

<TD>наименьший <I><A href="#Целые">целый</A></I> тип, <A href="#Поглощение типов">поглощающий</A>
оба операнда</TD>
</TR>

<TR>
<TD>OR &amp; ~ </TD>

<TD>BOOLEAN </TD>

<TD>BOOLEAN</TD>

<TD>BOOLEAN</TD>
</TR>

<TR VALIGN=TOP>
<TD>= # &lt; &lt;= &gt; &gt;=   </TD>

<TD><I><A href="#Числовые">числовой<BR>
</A></I>CHAR <BR>
символьный массив, строка</TD>

<TD><I><A href="#Числовые">числовой<BR>
</A></I>CHAR <BR>
символьный массив, строка</TD>

<TD>BOOLEAN<BR>
BOOLEAN<BR>
BOOLEAN</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>= # </TD>

<TD>BOOLEAN<BR>
SET <BR>
NIL, тип указатель T0 или T1<BR>
процедурный тип T, NIL</TD>

<TD>BOOLEAN<BR>
SET <BR>
NIL, тип указатель T0 или T1<BR>
процедурный тип T, NIL</TD>

<TD>BOOLEAN<BR>
BOOLEAN<BR>
BOOLEAN<BR>
BOOLEAN</TD>
</TR>

<TR>
<TD>IN </TD>

<TD><I><A href="#Целые">целый</A></I> </TD>

<TD>SET </TD>

<TD>BOOLEAN</TD>
</TR>

<TR ALIGN=LEFT VALIGN=TOP>
<TD>IS </TD>

<TD>тип T0 </TD>

<TD>тип T1 </TD>

<TD>BOOLEAN</TD>
</TR>
</TABLE>

<H4><A NAME="Совпадение списков формальных параметров"></A>Совпадение списков
формальных параметров </H4>

<P>Два списка формальных параметров <I>совпадают</I> если </P>

<OL>
<LI>они имеют одинаковое количество параметров, и </LI>

<LI>они имеют или <I><A href="#Одинаковые">одинаковый</A></I> тип результата
функции или не имеют никакого, и </LI>

<LI>параметры в соответствующих позициях имеют <I><A href="#Равные типы">равные</A></I>
типы, и </LI>

<LI>параметры в соответствующих позициях - оба или параметры-значения или
параметры-переменные. </LI>
</OL>

<H2><A NAME="Приложение B: Синтаксис Оберона-2"></A>Приложение B: Синтаксис
Оберона-2 </H2>

<TABLE CELLSPACING=0 CELLPADDING=0 >
<TR VALIGN=TOP>
<TD>Модуль</TD>

<TD> = </TD>

<TD>MODULE идент &quot;;&quot; [СписокИмпорта] ПослОбъявл [BEGIN ПослОператоров]
END идент &quot;.&quot;.</TD>
</TR>

<TR VALIGN=TOP>
<TD>СписокИмпорта</TD>

<TD> = </TD>

<TD>IMPORT [идент &quot;:=&quot;] идент {&quot;,&quot; [идент &quot;:=&quot;]
идент} &quot;;&quot;.</TD>
</TR>

<TR VALIGN=TOP>
<TD>ПослОбъявл</TD>

<TD> = </TD>

<TD>{ CONST {ОбъявлКонст &quot;;&quot; } | TYPE {ОбъявлТипа &quot;;&quot;
} | VAR {ОбъявлПерем &quot;;&quot; }} {ОбъявлПроц &quot;;&quot; | ОпережающееОбъяв&quot;;&quot;}.</TD>
</TR>

<TR VALIGN=TOP>
<TD>ОбъявлКонст</TD>

<TD> = </TD>

<TD>ИдентОпр &quot;=&quot; КонстВыраж.</TD>
</TR>

<TR>
<TD>ОбъявлТипа  </TD>

<TD> = </TD>

<TD>ИдентОпр &quot;=&quot; Тип.</TD>
</TR>

<TR>
<TD>ОбъявлПерем</TD>

<TD> = </TD>

<TD>СписокИдент &quot;:&quot; Тип.</TD>
</TR>

<TR VALIGN=TOP>
<TD><FONT SIZE=+0>ОбъявлПроц  </FONT></TD>

<TD> = </TD>

<TD><FONT SIZE=+0>PROCEDURE [Приемник] ИдентОпр [ФормальныеПарам]&quot;;&quot;
</FONT>ПослОбъявл [BEGIN ПослОператоров] END идент.</TD>
</TR>

<TR VALIGN=TOP>
<TD>ОпережающееОбъяв </TD>

<TD> = </TD>

<TD>PROCEDURE &quot;^&quot; [Приемник] ИдентОпр [ФормальныеПарам].</TD>
</TR>

<TR VALIGN=TOP>
<TD>ФормальныеПарам </TD>

<TD> = </TD>

<TD>&quot;(&quot; [СекцияФП {&quot;;&quot; СекцияФП}] &quot;)&quot; [&quot;:&quot;
УточнИдент].</TD>
</TR>

<TR>
<TD>СекцияФП</TD>

<TD> = </TD>

<TD>[VAR] идент {&quot;,&quot; идент} &quot;:&quot; Тип.</TD>
</TR>

<TR>
<TD>Приемник </TD>

<TD> = </TD>

<TD>&quot;(&quot; [VAR] идент &quot;:&quot; идент &quot;)&quot;.</TD>
</TR>

<TR VALIGN=TOP>
<TD>Тип</TD>

<TD> = </TD>

<TD>УточнИдент | ARRAY [КонстВыраж {&quot;,&quot; КонстВыраж}] OF Тип | RECORD
[&quot;(&quot;УточнИдент&quot;)&quot;] СписокПолей {&quot;;&quot; СписокПолей}
END | POINTER TO Тип | PROCEDURE [ФормальныеПарам].</TD>
</TR>

<TR>
<TD>СписокПолей</TD>

<TD> = </TD>

<TD>[СписокИдент &quot;:&quot; Тип].</TD>
</TR>

<TR>
<TD>ПослОператоров</TD>

<TD> = </TD>

<TD>Оператор {&quot;;&quot; Оператор}.</TD>
</TR>

<TR VALIGN=TOP>
<TD>Оператор</TD>

<TD> = </TD>

<TD>[ Обозначение &quot;:=&quot; Выраж <BR>
| Обозначение [&quot;(&quot; [СписокВыраж] &quot;)&quot;] <BR>
| IF Выраж THEN ПослОператоров {ELSIF Выраж THEN ПослОператоров} [ELSE ПослОператоров]
END <BR>
| CASE Выраж OF Вариант {&quot;|&quot; Вариант} [ELSE ПослОператоров] END
<BR>
| WHILE Выраж DO ПослОператоров END <BR>
| REPEAT ПослОператоров UNTIL Выраж <BR>
| FOR идент &quot;:=&quot; Выраж TO Выраж [BY КонстВыраж] DO ПослОператоров
END <BR>
| LOOP ПослОператоров END <BR>
| WITH Охрана DO ПослОператоров {&quot;|&quot; Охрана DO ПослОператоров}
<BR>
[ELSE ПослОператоров] END <BR>
| EXIT <BR>
| RETURN [Выраж] ].</TD>
</TR>

<TR VALIGN=TOP>
<TD>Вариант</TD>

<TD> = </TD>

<TD>[МеткиВарианта {&quot;,&quot; МеткиВарианта} &quot;:&quot; ПослОператоров].</TD>
</TR>

<TR>
<TD>МеткиВарианта</TD>

<TD> = </TD>

<TD>КонстВыраж [&quot;..&quot; КонстВыраж].</TD>
</TR>

<TR>
<TD>Охрана</TD>

<TD> = </TD>

<TD>УточнИдент &quot;:&quot; УточнИдент.</TD>
</TR>

<TR>
<TD>КонстВыраж</TD>

<TD> = </TD>

<TD>Выраж.</TD>
</TR>

<TR>
<TD>Выраж</TD>

<TD> = </TD>

<TD>ПростоеВыраж [Отношение ПростоеВыраж].</TD>
</TR>

<TR>
<TD>ПростоеВыраж</TD>

<TD> = </TD>

<TD>[&quot;+&quot; | &quot;-&quot;] Слагаемое {ОперСлож Слагаемое}.</TD>
</TR>

<TR>
<TD>Слагаемое</TD>

<TD> = </TD>

<TD>Множитель {ОперУмн Множитель}.</TD>
</TR>

<TR VALIGN=TOP>
<TD>Множитель</TD>

<TD> = </TD>

<TD>Обозначение [&quot;(&quot; [СписокВыраж] &quot;)&quot;] | число | символ
| строка | NIL | Множество | &quot;(&quot; Выраж &quot;)&quot; | &quot;
~ &quot; Множитель.</TD>
</TR>

<TR VALIGN=TOP>
<TD>Множество</TD>

<TD> = </TD>

<TD>&quot;{&quot; [Элемент {&quot;,&quot; Элемент}] &quot;}&quot;.</TD>
</TR>

<TR>
<TD>Элемент</TD>

<TD> = </TD>

<TD>Выраж [&quot;..&quot; Выраж].</TD>
</TR>

<TR>
<TD>Отношение</TD>

<TD> = </TD>

<TD>&quot;=&quot; | &quot;#&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot;
| &quot;&gt;&quot; | &quot;&gt;=&quot; | IN | IS.</TD>
</TR>

<TR>
<TD>ОперСлож</TD>

<TD> = </TD>

<TD>&quot;+&quot; | &quot;-&quot; | OR.</TD>
</TR>

<TR>
<TD>ОперУмн</TD>

<TD> = </TD>

<TD>&quot;*&quot; | &quot;/&quot; | DIV | MOD | &quot;&amp;&quot;.</TD>
</TR>

<TR VALIGN=TOP>
<TD>Обозначение</TD>

<TD> = </TD>

<TD>УточнИдент {&quot;.&quot; идент | &quot;[&quot; СписокВыраж &quot;]&quot;
| &quot;^&quot; | &quot;(&quot; УточнИдент &quot;)&quot;}.</TD>
</TR>

<TR VALIGN=TOP>
<TD>СписокВыраж</TD>

<TD> = </TD>

<TD>Выраж {&quot;,&quot; Выраж}. СписокИдент = ИдентОпр {&quot;,&quot;
ИдентОпр}.</TD>
</TR>

<TR VALIGN=TOP>
<TD>УточнИдент</TD>

<TD> = </TD>

<TD>[идент &quot;.&quot;] идент. ИдентОпр = идент [ &quot;*&quot; | &quot;-&quot;
].</TD>
</TR>
</TABLE>

<H2><A NAME="Приложение C: Модуль SYSTEM"></A>Приложение C: Модуль SYSTEM
</H2>

<P>Модуль SYSTEM содержит некоторые типы и процедуры, которые необходимы
для реализации операций <I>низкого уровня</I>, специфичных для данного
компьютера и/или реализации. Они включают, например, средства для доступа
к устройствам, которые управляются компьютером, и средства, позволяющие
обойти правила совместимости типов, наложенные определением языка. Настоятельно
рекомендуется ограничить использование этих средств специфическими модулями
(модулями <I>низкого уровня</I>). Такие модули непременно являются непереносимыми,
но легко распознаются по идентификатору SYSTEM, появляющемуся в их списке
импорта. Следующие спецификации действительны для реализации Оберон-2 на
компьютере Ceres. <BR>
     Модуль SYSTEM экспортирует тип BYTE со следующими характеристиками:
переменным типа BYTE можно присваивать значения переменных типа CHAR или
SHORTINT. Если формальный параметр-переменная имеет тип ARRAY OF BYTE,
то соответствующий фактический параметр может иметь любой тип. <BR>
Другой тип, экспортируемый модулем SYSTEM, - тип PTR. Переменным типа PTR
могут быть присвоены значения переменных-указателей любого типа. Если формальный
параметр-переменная имеет тип PTR, фактический параметр может быть указателем
любого типа. <BR>
Процедуры, содержащиеся в модуле SYSTEM, перечислены в таблицах. Большинство
их соответствует одиночным командам и компилируются непосредственно в машинный
код. О деталях читатель может справиться в описании процессора. В таблице
<I>v </I>обозначает переменную, <I>x, y, a,</I> и <I>n </I>- выражения,
а <I>T </I>- тип. </P>

<P><I>Процедуры-функции </I></P>

<TABLE BORDER=1 >
<TR ALIGN=CENTER>
<TD>Название</TD>

<TD>Типы аргументов</TD>

<TD>Тип результата</TD>

<TD>Функция</TD>
</TR>

<TR VALIGN=TOP>
<TD>ADR(v)</TD>

<TD>любой</TD>

<TD>LONGINT</TD>

<TD>адрес переменной v</TD>
</TR>

<TR VALIGN=TOP>
<TD>BIT(a,n) </TD>

<TD>a: LONGINT; n:целый</TD>

<TD>BOOLEAN</TD>

<TD>n-й бит Память[a]</TD>
</TR>

<TR VALIGN=TOP>
<TD>CC(n) </TD>

<TD>целая константа</TD>

<TD>BOOLEAN</TD>

<TD>условие n (0 &lt;= n &lt;= 15)</TD>
</TR>

<TR VALIGN=TOP>
<TD>LSH(x,n) </TD>

<TD>x: целый, CHAR, BYTE; n: целый</TD>

<TD>совпадает с типом x</TD>

<TD>логический сдвиг</TD>
</TR>

<TR VALIGN=TOP>
<TD>ROT(x,n) </TD>

<TD>x: целый, CHAR, BYTE; n: целый  </TD>

<TD>совпадает с типом x  </TD>

<TD>циклический сдвиг</TD>
</TR>

<TR VALIGN=TOP>
<TD>VAL(T,x) </TD>

<TD>T, x: любого типа</TD>

<TD>T</TD>

<TD>x интерпретируется как значение типа T</TD>
</TR>
</TABLE>

<P><I>Собственно процедуры </I></P>

<TABLE BORDER=1 >
<TR ALIGN=CENTER>
<TD>Название </TD>

<TD>Типы аргументов </TD>

<TD>Функция</TD>
</TR>

<TR VALIGN=TOP>
<TD>GET(a, v) </TD>

<TD>a: LONGINT; v: любой <A href="#6.1 Основные типы">основной тип</A>,
указатель, процедурный тип</TD>

<TD>v := Память[a]</TD>
</TR>

<TR VALIGN=TOP>
<TD>PUT(a, x) </TD>

<TD>a: LONGINT; x: любой <A href="#6.1 Основные типы">основной тип</A>,
указатель, процедурный тип</TD>

<TD>Память[a] := x</TD>
</TR>

<TR VALIGN=TOP>
<TD>GETREG(n, v) </TD>

<TD>n: целая константа; v: любой <A href="#6.1 Основные типы">основной
тип</A>, указатель, процедурный тип</TD>

<TD>v := Регистр n</TD>
</TR>

<TR VALIGN=TOP>
<TD>PUTREG(n, x) </TD>

<TD>n: целая константа; x: любой <A href="#6.1 Основные типы">основной
тип</A>, указатель, процедурный тип</TD>

<TD>Регистр n := x</TD>
</TR>

<TR VALIGN=TOP>
<TD>MOVE(a0,a1,n)  </TD>

<TD>a0, a1: LONGINT; n: целый</TD>

<TD>Память[a1..a1+n-1] := Память[a0..a0+n-1]</TD>
</TR>

<TR VALIGN=TOP>
<TD>NEW(v, n) </TD>

<TD>v: любой указатель; n: целый</TD>

<TD>размещает блок памяти размером n байт; присваивает его адрес переменной
v</TD>
</TR>
</TABLE>

<H2><A NAME="Приложение D: Среда Оберон"></A>Приложение D: Среда Оберон
</H2>

<P>Программы на Обероне-2 обычно выполняются в среде, которая обеспечивает
<I><A href="#d1. Команды">активацию команд</A>, <A href="#d3. Сбор мусора">сбор
мусора</A></I>, <I><A href="#d2. Динамическая загрузка модулей">динамическую
загрузку модулей</A></I> и определенные <I><A href="#d5. Структуры данных времени выполнения">структуры
данных времени выполнения</A></I>. Не являясь частью языка, эта среда способствует
увеличению мощности Оберона-2 и до некоторой степени подразумевается при
определении языка. В приложении D описаны существенные особенности типичной
Оберон-среды и даны советы по peализации. Подробности можно найти в [1],
[2], и [3]. </P>

<H3><A NAME="D1. Команды"></A>D1. Команды </H3>

<P>Команда - это любая процедура <I>P</I>, которая экспортируется модулем
<I>M</I> и не имеет параметров. Она обозначается <I>M.P</I> и может быть
активирована под таким именем из оболочки операционной системы. В Обероне
пользователь вызывает команды вместо программ или модулей. Это дает лучшую
структуру управления и предоставляет модули с несколькими точками входа.
Когда вызывается команда <I>M.P</I>, модуль <I>M</I> динамически загружается,
если он уже не был в памяти (см. <A href="#d2. Динамическая загрузка модулей">D2</A>)
и выполняется процедура <I>P</I>. Когда <I>P</I> завершается, <I>M</I>
остается загруженным. Все глобальные переменные и структуры данных, которые
могут быть достигнуты через глобальные переменные-указатели в <I>M</I>,
сохраняют значения. Когда <I>P</I> (или другая команда <I>M</I>) вызывается
снова, она может продолжать использовать эти значения. <BR>
     Следующий модуль демонстрирует использование команд. Он реализует
абстрактную структуру данных <I>Counter</I>, которая содержит переменную-счетчик
и обеспечивает команды для увеличения и печати его значения. </P>

<UL>
<P>MODULE Counter; <BR>
     IMPORT Texts, Oberon; </P>

<P>     VAR <BR>
          counter: LONGINT; <BR>
          w: Texts.Writer; </P>

<P>PROCEDURE Add*; (* получает числовой аргумент из командной строки *)
<BR>
     VAR s: Texts.Scanner; <BR>
BEGIN <BR>
     Texts.OpenScanner(s, Oberon.Par.text, Oberon.Par.pos); <BR>
     Texts.Scan(s); <BR>
     IF s.class = Texts.Int THEN INC(counter, s.i) END <BR>
END Add; </P>

<P>PROCEDURE Write*; <BR>
BEGIN <BR>
     Texts.WriteInt(w, counter, 5); Texts.WriteLn(w); <BR>
     Texts.Append(Oberon.Log, w.buf) <BR>
END Write; </P>

<P>BEGIN counter := 0; Texts.OpenWriter(w) <BR>
END Counter. </P>
</UL>

<P>Пользователь может выполнить следующие две команды: </P>

<UL>
<P><I>Counter.Add n      </I>Добавляет значение n к переменной counter
<BR>
<I>Counter.Write</I>       Выводит текущее значение counter на экран </P>
</UL>

<P>Так как команды не содержат параметров, они должны получать свои аргументы
из операционной системы. Вообще команды вольны брать параметры отовсюду
(например из текста после команды, из текущего выбранного фрагмента или
из отмеченного окна просмотра). Команда <I>Add</I> использует сканер (тип
данных, обеспечиваемый Оберон-системой) чтобы читать значение, которое
следует за нею в командной строке. <BR>
Когда <I>Counter.Add</I> вызывается впервые, модуль <I>Counter</I> загружается
и выполняется его тело. Каждое обращение <I>Counter.Add n </I>увеличивает
переменную <I>counter </I>на <I>n.</I> Каждое обращение <I>Counter.Write</I>
выводит текущее значение <I>counter</I> на экран. <BR>
     Поскольку модуль остается загруженным после выполнения его команд,
должен существовать явный способ выгрузить его (например, когда пользователь
хочет заменить загруженную версию перекомпилированной версией). Оберон-система
содержит команду, позволяющую это сделать. </P>

<H3><A NAME="D2. Динамическая загрузка модулей"></A>D2. Динамическая загрузка
модулей </H3>

<P>Загруженный модуль может вызывать команду незагруженного модуля, задавая
ее имя как строку. Специфицированный модуль при этом динамически загружается
и выполняется заданная команда. Динамическая загрузка позволяет пользователю
запустить программу как небольшой набор базисных модулей и расширять ее,
добавляя последующие модули во время выполнения по мере необходимости.
<BR>
     Модуль <I>M0</I> может вызвать динамическую загрузку модуля <I>M1</I>
без того, чтобы импортировать его. <I>M1</I> может, конечно, импортировать
и использовать <I>M0</I>, но <I>M0 </I>не должен знать о существовании
<I>M1</I>. <I>M1</I> может быть модулем, который спроектирован и реализован
намного позже <I>M0</I>. </P>

<H3><A NAME="D3. Сбор мусора"></A>D3. Сбор мусора </H3>

<P>В Обероне-2 стандартная процедура NEW используется, чтобы распределить
блоки данных в свободной памяти. Нет, однако, никакого способа явно освободить
распределенный блок. Взамен Оберон-среда использует <I>сборщик мусора</I>
чтобы найти блоки, которые больше не используются и сделать их снова доступными
для распределения. Блок считается используемым только если он может быть
достигнут через глобальную переменную-указатель по цепочке указателей.
Разрыв этой цепочки (например, установкой указателя в NIL) делает блок
утилизируемым. <BR>
     Сборщик мусора освобождает программиста от нетривиальной задачи правильного
освобождения структур данных и таким образом помогает избегать ошибок.
Возникает, однако, необходимость иметь информацию о динамических данных
во время выполнения (см. <A href="#d5. Структуры данных времени выполнения">D5</A>).
</P>

<H3><A NAME="D4. Смотритель"></A>D4. Смотритель </H3>

<P>Интерфейс модуля (объявления экспортируемых объектов) извлекается из
модуля так называемым <I>смотрителем</I>, который является отдельным инструментом
среды Оберон. Например, смотритель производит следующий интерфейс <A href="#module trees">модуля
<I>Trees</I></A> из <A href="#11. Модули">Гл. 11</A>. </P>

<P>DEFINITION Trees; <BR>
     TYPE<BR>
          Tree = POINTER TO Node; <BR>
          Node = RECORD <BR>
               name: POINTER TO ARRAY OF CHAR; <BR>
               PROCEDURE (t: Tree) Insert (name: ARRAY OF CHAR); <BR>
               PROCEDURE (t: Tree) Search (name: ARRAY OF CHAR): Tree;
<BR>
               PROCEDURE (t: Tree) Write; <BR>
          END; <BR>
     PROCEDURE I
     PROCEDURE Init (VAR t: Tree); <BR>
END Trees. </P>

<P>Для типа запись смотритель также собирает все процедуры, связанные с
этим типом, и показывает их заголовки в объявлении типа запись. </P>

<H3><A NAME="D5. Структуры данных времени выполнения"></A>D5. Структуры
данных времени выполнения </H3>

<P>Некоторая информация о записях должна быть доступна во время выполнения:
Динамический тип записей необходим для проверки и охраны типа. Таблица
с адресами процедур, связанных с записью, необходима для их вызова. Наконец,
сборщик мусора нуждается в информации о расположении указателей в динамически
распределенных записях. Вся эта информация сохраняется в так называемых
<I>дескрипторах типа</I>. Один дескриптор необходим во время выполнения
для каждого типа записи. Ниже показана возможная реализация дескрипторов
типа. <BR>
Динамический тип записи соответствует адресу дескриптора типа. Для динамически
распределенных записей этот адрес сохраняется в так называемом <I>теге
типа</I>, который предшествует фактическим данным записи и является невидимым
для программиста. Если <I>t</I> - переменная типа <I>CenterTree</I> (см.
<A href="#Примеры гл.6">пример в Гл. 6</A>), рисунок D5.1 показывает одну
из возможных реализаций структур данных времени выполнения. </P>

<CENTER><P><IMG src="figd5100.gif" HEIGHT=165 WIDTH=387></P></CENTER>

<CENTER><P>Рис. D5.1 переменная <I>t</I> типа <I>CenterTree</I>, запись
<I>t^</I>, на которую она указывает, и дескриптор типа </P></CENTER>

<P>Поскольку и таблица адресов процедур и таблица смещений указателей должны
иметь фиксированное смещение относительно адреса дескриптора типа, и поскольку
они могут расти, когда тип расширяется и добавляются новые процедуры и
указатели, то таблицы размещены в противоположных концах дескриптора типа
и растут в разных направлениях. <BR>
Связанная с типом процедура <I>t.P</I> вызывается как <I>t^.tag^.ProcTab[IndexP]</I>.
Индекс таблицы процедур для каждой связанной с типом процедуры известен
во время компиляции. Проверка типа<I> v IS T</I> транслируется в <I>v^.tag^.BaseTypes
[ExtensionLevelT] = TypeDescrAdrT</I>. И уровень расширения типа запись
(<I>ExtensionLevelT</I>), и адрес описателя типа (<I>TypeDescrAdrT</I>)
известны во время компиляции. Например, уровень расширения <I>Node</I>
- 0 (этот тип не имеет базового типа), а уровень расширения <I>CenterNode</I>
равен 1. </P>

<P>[1] N.Wirth, J.Gutknecht: The Oberon System. Software Practice and Experience
19, 9, Sept. 1989 <BR>
[2] M.Reiser: The Oberon System. User Guide and Programming Manual. Addison-Wesley,
1991 <BR>
[3] C.Pfister, B.Heeb, J.Templ: Oberon Technical Notes. Report 156, ETH
Zurich, March 1991</P>

</BODY>
</HTML>

<!-- This document saved from http://www.uni-vologda.ac.ru/oberon/o2rus.htm -->
